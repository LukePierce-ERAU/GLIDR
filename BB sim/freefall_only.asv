%% Full simulation of fall from 36.5km for DCR configurations
clear
close all

%% Next steps for DCR?
%   -   Develop Glide condition [Thomas]
%   -   Create a system that can do everything up to glide condition in one
%       main script [Kaylee}
%   -   impliment full 3DOF with theta-AoA relationship +++++++++++++++++++
%   -   Recreate in simulink [PDR task]
%   -   cm calc [josiah]




%% GEOMETRY ASSUMPTION SECTIONS AND GLOBAL VARIABLES ++++++++++++++++++++++


config = 3; % Change to run sims on each config
% 1 ==== Blended Wing Body
% 2 ==== Rogallo Wing
% 3 ==== Bullet Bill


DESIGN = configuration(config);
master = struct();

end_sim = size(DESIGN.S,2);
for ii = 1:1:end_sim


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Freefall until desired q
options = odeset('Events', @y1_free);
place_free = @(t,y) funfree(t,y,DESIGN,ii);
[t,y,te,ye,ei] = ode45(place_free, [0 10000], [36000;0], options); % need to impliment aoa for linear region

for k = 1:numel(t)
    [~,moment(k,:)] = place_free(t(k),y(k,:));
end

m_name = ['moment', num2str(ii)];
master.(m_name) = moment;

freevar(:,:,ii) = {t;y(:,1);abs(y(:,2))};
free_out(:,:,ii) = [te,ye,ei];

global pull_init
pull_init = te;

glide_inip(1,ii) = te;

% Pullout @ desired q
% options = odeset('Events', @y1_pull);
% place_pull = @(t,y) funpull(t,y,DESIGN,ii);
% [t,y,te,ye,ei] = ode45(place_pull, [0 5000], [0;ye(1,1);ye(1,2);-pi/2], options); % need to impliment theta and Q

% pull(:,:,ii) = {t;y(:,1);y(:,2);abs(y(:,3));y(:,4)};
% pull_out(:,:,ii) = [te,ye,ei];
% 
% glide_initp(1,ii) = te;

% going from fast to ideal cruise

% options = odeset('Events', @y1_glide);
% chat = @(t,y) funglide(t,y,DESIGN,ii);
% [t,y,te,ye,ei] = ode15s(chat, [0 100], [ye(1,1);ye(1,2);abs(ye(1,3)); 0], options); % need to impliment theta and Q

ic = [0;ye(1,1);abs(ye(1,2)); 0];

% velo(:,1) = sqrt(y(:,3).^2+y(:,4).^2);
% %t = zeros(size(velo,1),1);
% glide(:,:,ii) = {t;y(:,1);y(:,2);velo(:,1)};

clear velo

end


%% Cool Plots

free = struct();

for free_ind = 1:size(freevar,3)
    free_mat_ind = cell2mat(freevar(:,:,free_ind));
    t = free_mat_ind(1:size(free_mat_ind,1)/3);
    x = zeros(size(free_mat_ind,1)/3,1);
    alt = free_mat_ind(size(free_mat_ind,1)/3+1:size(free_mat_ind,1)/3*2);
    speed = free_mat_ind(size(free_mat_ind,1)/3*2+1:end);
    t_name = ['t', num2str(free_ind)];
    x_name = ['x', num2str(free_ind)];
    alt_name = ['alt', num2str(free_ind)];
    speed_name = ['speed', num2str(free_ind)];
    free.(t_name) = t;
    free.(x_name) = x;
    free.(alt_name) = alt;
    free.(speed_name) = speed;
end

configs = {'free', 'pull', 'glide', 'steady'};

for jj = 1:1:ii
master.(['t', num2str(jj)]) = vertcat(free.(['t',num2str(jj)]));  %,steady.(['t',num2str(jj)]));
master.(['x', num2str(jj)]) = vertcat(free.(['x',num2str(jj)])); %steady.(['x',num2str(jj)]));
master.(['alt', num2str(jj)]) = vertcat(free.(['alt',num2str(jj)])); %,steady.(['alt',num2str(jj)]));
master.(['speed', num2str(jj)]) = vertcat(free.(['speed',num2str(jj)]));  %steady.(['speed',num2str(jj)]));
end

%% Altitude over Time
figure
hold on
plot(master.t1/60,master.alt1/1000,'m','LineWidth',2)
plot(master.t6/60,master.alt6/1000,'k','LineWidth',2)
plot(master.t10/60,master.alt10/1000,'b','LineWidth',2)
grid on
title('Altitude over Time','FontSize',18)
xlabel('Time [mins]','FontSize',16)
ylabel('Altitude [km]','FontSize',16)

%% Altitude VS Speed
figure
hold on
plot(master.speed1,master.alt1/1000,'m','LineWidth',2)
plot(master.speed6,master.alt6/1000,'k','LineWidth',2)
plot(master.speed10,master.alt10/1000,'b','LineWidth',2)
grid on
title('Altitude over Speed','FontSize',18)
xlabel('Speed [m/s]','FontSize',16)
ylabel('Altitude [km]','FontSize',16)

%% Figure: Airbreak moment vs. Altitude
figure;
plot(master.moment1, master.alt1, 'b', 'LineWidth', 2);
set(gca, 'YDir', 'reverse'); % Altitude decreases downward
xlabel('Moment',16);
ylabel('Altitude (m)',16);
title('Moment vs. Altitude', 'FontSize',18);
grid on;

%% Functions for simulations

% Freefall section ode ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function [dydt,moment] = funfree(t,y,DESIGN,ii)

% Get atmospheric properties at current height
    [T, a, P, rho, nu, mu] = atmosisa(y(1), 'extended', true);

    q = 0.5 * rho * y(2)^2; % Dynamic pressure
    
    % Drag Buildup for changing Re and flight condition
    Re = rho.*DESIGN.c.*abs(y(2))./mu;
    cL = 0;
    [cD0,cDi] = drag(Re,cL,DESIGN,ii);
    cD = cD0 + cDi;

    C_d_airbrake = 2.2; % Given Cd
    D_airbrake = q *  DESIGN.S_airbrake * C_d_airbrake; % Airbrake drag force
    moment(numel(t),1) = D_airbrake * DESIGN.airbrake_ac; % This is for 1 of 3 airbrakes

    drag_force = 0.5 * cD * DESIGN.S(ii) * rho * y(2).^2;

    % Calculate the drag force and acceleration due to gravity
    % Drag force (assumes velocity is y(2))
    dydt = [y(2); -DESIGN.g + (drag_force+3*D_airbrake*sin(pi/4)^2) ./ DESIGN.m]; % [dy/dt, dv/dt]
end

function [position,isterminal,direction] = y1_free(t,y)
[T, a, P, rho, nu, mu] = atmosisa(y(1), 'extended', true);

% position = y(2) + 200; % The value that we want to be zero (speed)
    % q_current = 0.5 * rho * y(2)^2;
    % position = q_current - 10; % Stop when q = 1700 Pa
    target_altitude = 1700;
    position = y(1) - target_altitude ;
    isterminal = 1;  % Halt integration 
    direction = 0;   % The zero can be approached from either direction
end

% Pullout section ode ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function dydt = funpull(t,y,DESIGN,ii)



% Get atmospheric properties at current height
    [T, a, P, rho, nu, mu] = atmosisa(y(2), 'extended', true);

    % Drag Buildup for changing Re and flight condition
    Re = rho.*DESIGN.c.*abs(y(3))./mu;

    % TO BE FURTHER EVALUATED++++++++++++++++++++++++++++++++++++++++
    % Estimation based on flaps to to create negative lift 
    global pull_init

    if t == pull_init
        cL = 0;
    else
        cL = -0.5;
    end
   
    
[cD0,cDi] = drag(Re,cL,DESIGN,ii);
cD = cD0 + cDi;
    
drag_force = 0.5 .* rho .* y(3)^2 .* DESIGN.S(ii) .* cD;
lift_force = 0.5 .* rho .* y(3)^2 .* DESIGN.S(ii) .* cL;

Q = ( .5*rho*(y(3)^2)*cL*(DESIGN.S(ii)/DESIGN.m) - DESIGN.g*cos(y(4)) )/y(3);
    
 % Calculate the drag force and acceleration due to gravity
     % Drag force (assumes velocity is y(2))
    dydt = [abs(y(3)).*cos(y(4)); abs(y(3)).*sin(y(4)); DESIGN.g.*sin(y(4))-drag_force/DESIGN.m; Q]; % [dx/dt, dy/dt, dv/dt, dtheta/dt]
end

function [position,isterminal,direction] = y1_pull(t,y)
    position = y(4); % The value that we want to be zero (theta)
    isterminal = 1;  % Halt integration 
    direction = 0;   % The zero can be approached from either direction
end

function [t,y,L_D,ic,te,cL] = sadglide(ic,DESIGN,ii)
% Aircraft parameters

    C_L0 = 0.3;              % Lift coefficient at zero angle of attack (dimensionless)
             % Parasitic drag coefficient (dimensionless)
    k = 1/(DESIGN.e(ii)*pi*DESIGN.AR(ii));                % Induced drag factor (dimensionless)

    g = 9.81;                % Gravitational acceleration (m/sÂ²)
    
    % Flight conditions (inputs)
    alt = ic(2);         % Altitude (m)
    [T, a, P, rho, nu, mu] = atmosisa(alt, 'extended', true);

    % Drag Buildup for changing Re and flight condition
    Re = rho.*DESIGN.c.*abs(ic(3))./mu;
    cD0 = drag(Re,0,DESIGN,ii);

    % Compute weight
    W = DESIGN.m * DESIGN.g;               % Weight of the aircraft (N)
    
    % Stall angle (radians) (stall angle assumed for typical subsonic aircraft)
    stall_angle = deg2rad(15);  
    
    % Target glide velocity (optimal velocity determined earlier)
    % Assuming the optimized value was calculated previously
    target_velocity = sqrt((2 * W) / (rho * DESIGN.S(ii) * C_L0));     % Example target velocity in m/s (can be calculated from previous results)
    
    % Initial condition: Aircraft starts with a higher glide velocity
    V_current = abs(ic(3));           % Higher initial glide velocity (m/s)
    tolerance = 0.01;         % Convergence tolerance for velocity
    xdistance_traveled = 0;    % Distance traveled (m)
    ydistance_traveled = 0;
    
    % Define lift coefficient limits (realistic values)
    CL_max = 2.5;             % Maximum CL (typically around this for subsonic aircraft with flaps)
    CL_min = 0.1;             % Minimum CL (reasonable lower bound)

    % Iterate until the velocity is trimmed to the target
    iter = 0;
    while abs(V_current - target_velocity) > tolerance
        % Calculate dynamic lift coefficient (CL) based on AoA and flap settings
        % Here AoA is replaced by glide path angle (gamma), which will control the desired CL
        
        % Calculate the current lift (L) and drag (D) forces
        alpha = atan(W / (0.5 * rho * V_current^2 * DESIGN.S(ii) * C_L0));  % Initial alpha calculation
        
        % Calculate CL using current angle of attack
        % C_L = C_L0 + DESIGN.cLalpha(ii) * alpha
        C_L = W / (0.5 * rho * V_current^2 * DESIGN.S(ii));
        
        % Ensure CL stays within reasonable limits (0.5 < CL < 2.5)
        if C_L > CL_max
            C_L = CL_max;
        elseif C_L < CL_min
            C_L = CL_min;
        end
        
        % Induced drag model (quadratic relation to lift coefficient)
        C_D = cD0 + k * C_L^2;
        
        % Calculate steady glide conditions
        L = 0.5 * rho * V_current^2 * C_L * DESIGN.S(ii);  % Lift force (N)
        D = 0.5 * rho * V_current^2 * C_D * DESIGN.S(ii) * DESIGN.S_ratio;  % Drag force (N)
        
% INSTEAD BLEEDING SPEED AT A CONSTANT ALT================================

        % Calculate glide path angle (gamma) for current L and D
        gamma = D / L;  % Glide path angle (radians)
        
        % Angle of attack is approximately equal to the glide path angle
        % alpha = gamma;
        
        % Velocity slip into x and y components for distance
        V_Cx = V_current.*cos(gamma);
        V_Cy = V_current.*sin(gamma);
        V_Cy = 0;
        % Calculate distance traveled and altitude lost during this step
        xdistance_traveled = + V_Cx * 1;  % Assume each iteration is 1 second
        ydistance_traveled = + V_Cy * 1;  % Assume each iteration is 1 second

        % Apply drag force to reduce velocity
        V_new = V_current - D / DESIGN.m * 1;  % Apply drag force to reduce speed (assume 1 second steps)
        
        % Update current velocity and ensure it stays above the target
        V_current = max(V_new, target_velocity);
        
        % Prevent angle of attack from reaching stall (ensure alpha does not exceed stall angle)
        if alpha > stall_angle
            alpha = stall_angle;
        end
        
        % Increment iteration count and saving needed parameters
        iter = iter + 1;
        if iter == 1
        L_D(iter,1) = L/D; 
        y(iter,1) = ic(1);
        y(iter,2) = alt;
        y(iter,3) = ic(3);
        y(iter,4) = V_Cy;
        t(iter,1) = iter;
        cL(iter,1) = C_L;
        else
        L_D(iter,1) = L/D; 
        y(iter,1) = y(iter-1,1) + xdistance_traveled;
        y(iter,2) = y(iter-1,2) - ydistance_traveled;
        y(iter,3) = V_Cx;
        y(iter,4) = V_Cy;
        t(iter,1) = iter;
        cL(iter,1) = C_L;
    end
    end

    ic = [y(iter,1), y(iter,2), y(iter,3), y(iter,4)];
    te = t(iter);
end

function [position,isterminal,direction] = y1_glide(t,y)
    position = y(2); % The value that we want to be zero (altitude)
    isterminal = 1;  % Halt integration 
    direction = 0;   % The zero can be approached from either direction
end
