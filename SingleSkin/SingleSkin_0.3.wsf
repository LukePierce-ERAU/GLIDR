<job>
<script language="JScript">
/*
Создает выкройки для однослойного параплана и кайта.
Версия 0.3

Инструкция:
1. Отключите перенос слов (важно!!!)
2. Измените ниже площадь крыла, количество секций и т.д.
3. Сохраните изменения и запустите скрипт двойным кликом мыши, рядом появятся файлы с расширением .dxf
4. Откройте wing_3d.dxf в программе Google SketchUp (в Pro через импорт, в обычном через плагин импорта dxf). Единицы измерения: миллиметры.
5. Откройте выкройки ribs.dxf и panels.dxf в программе CADViewX Lite и распечатайте их в масштабе 1:1

Как изменить форму крыла:
1. В графической оболочке SingleSkin.exe. Сохраните проект и скопируйте в массиы цифры из строк типа points_LE

Как изменить профиль:
1. Создайте в XFLR5 нужный профиль из как можно большего числа точек (около 300) и сохраните его с расширением .dat, откройте в Блокноте и удалите все точки, идущие после лобика нервюры, а остальные координаты скопируйте в массив foil ниже или сохраните в виде файла airfoil.dat в папке со скриптом

Что нового:
0.3: добавлена возможность вызова через командную строку из GUI, автозагрузка профиля foil из файла airfoil.dat, английский и русский язык в одном скрипте


steel17@rambler.ru
*/


// общие параметры
opt_Area = 16;			// площадь, м2
opt_AR = 4.7;			// удлинение

opt_Cells = 25;			// количество секций

opt_Kite_Lines = 0;		// длина кайтовых строп, м. 0 - строповка для параплана

// настройки профиля
opt_CoP = 31;			// центр давления на профиле на полетном угле атаки, % хорды. определяется при виртуальной продувке, например в XFLR5, используется для расчета центровки
opt_K = 6; 			// предполагаемое аэродинамическое качество (для параплана 6-7.5 единиц, для спидглайдера и кайта 4.5-5.5 единиц)

opt_AoA = 8;			// угол атаки в полете, обычно 7-9 градусов. используется для расчета центровки с учетом предполагаемого аэродинамического качества
opt_AoA_Tips = 6;		// геометрическая крутка (добавляется к углу атаки на ушах), обычно 4..6 градуса

opt_Camber_Center = 18;		// толщина профиля в центре, %
opt_Camber_Tip = 15;		// толщина профиля на ушах, %
opt_Tip_Width = 0.9;		// коэффициент уменьшения ширины секций к ушам, число от 0.8 до 1

// нервюры
opt_8p = 0;   	   		// 1 - по 8 треугольников на нервюре, 0 - по 4 треугольника
opt_Rib_Size = 11;		// высота треугольников в нервюрах, % хорды. 0 - объединять треугольники кончиками в точке схождения строп верхнего яруса (то есть самый верхний ярус как бы отсутствует, его роль выполняют сами нервюры)
opt_Rib_Koeff = 0.65;		// коэффициент линейного уменьшения высоты треугольников к хвосту. 1 - не уменьшать, 0.9 - хвостовой треугольник будет иметь высоту 90% от первого, 0.3 - хвостовой треугольник будет иметь высоту 30% от первого и т.д.
opt_Rib_Camber = 0;		// треугольники повторяющие форму профиля, высота в % от толщины профиля. 0 - не использовать. В текущей реализации в этом режиме треугольники ближе к хвосту могут не совсем совпадать с направлением строп, поэтому рекомендуется использовать предыдущий режим opt_Rib_Size и линейное уменьшение высоты к хвосту с помощью opt_Rib_Koeff.
opt_Rib_Straight = 0;		// 0 - изогнутые треугольники, 1 - треугольники с прямыми линиями

// строповка
opt_Bridle_Height = 67;     	// высота строповки, % от размаха
opt_Bridle_Riser = 50;		// длина свободных концов, см. для кайта обычно 10 см, чтобы использовать эту V-вилку с узелками для настройки угла атаки (0 - не создавать вилку для настройки угла атаки). для параплана обычно 50 см.
opt_Bridle_Riser_Dist = 40;	// расстояние между свободными концами, см
// верхний ярус
opt_Bridle_Upper = 32;		// высота верхнего яруса, % от высоты текущего яруса (не от общей высоты!)
opt_Bridle_Upper_Num = 3;	// количество строп верхнего яруса
// средний ярус
opt_Bridle_Middle = 50;		// высота среднего яруса, %
opt_Bridle_Middle_Num = 2;	// количество строп среднего яруса
// ушная стропа
opt_Tip_Line = 1; 	   	// 0 - не использовать отдельную стропу для ушей, 1 - использовать
opt_Tip_Line_Height = 22;	// высота верхнего яруса для ушной стропы, % от общей высоты, только если ушная стропа используется
// клеванты
opt_Brake = new Array(2,1);	// если два числа, то первое с какой нервюры начать от центральной секции, а второе с каким интервалом ставить клевантные стропы. иначе полное перечисление нервюр, к которым подведены стропы, начиная с центроплана (0 - корневая нервюра, 1 - следующая и т.д.)
opt_Brake_Upper = 22;		// высота верхнего уровня клевант, %
opt_Brake_Upper_Num = 4;	// количество строп в верхнем уровне клевант
opt_Brake_Middle = 45;		// высота среднего уровня клевант, %

// точки петелек
opt_Bridle_Points = new Array(5,87);  		// диапазон для точек крепления строп на куполе, % хорды. При ручном указании точек должно быть строго 4 или 8 штук (можно результат автоматического равномерного распределения посмотреть в bridles.txt и скорректировать точки вручную). Если для первой петельки указан % за пределами носика, она автоматически будет на расположена на краю носика. При 4 и 8 точках также отличается степень закругления треугольника у задней кромки
opt_Bridle_Points = new Array(15,27,50,80);	// неплохой вариант ручного задания для 4 точек на нервюре, перезаписывает предыдущую строчку

opt_Bridle_A0 = 2; 		// точка на верхней части лобика, где начинается усиление лобика прямым шнуром, в % хорды (можно не использовать)
opt_Bridle_L0 = 16.71;	  	// точка начала лески на лобике (обозначается на чертеже вертикальной линией), в % хорды (обычно от 16 до 27)

// печать
print = 1;			// 0 - не создавать dxf файлы с печатными шаблонами, 1 - все выкройки нервюр и полотен в одном файле ribs.dxf и panels.dxf, 2 - каждую нервюру и полотно в отдельном файле в папке _print с названиями rib_1_of_6.dxf, rib_2_of_6.dxf, panel_1_of_6.dxf и т.д. Нумерация от центральной секции.
print_overlay_y = 0;	 	// 0 - в одном файле печатать выкройки не пересекаясь, иначе смещение в см одной выкройки относительно другой по вертикали. по умолчанию 5 см.
print_overlay_x = 0;		// ... по горизонтали. по умолчанию 3 см (подбирайте значения чтобы выкройки при печати не закрывали друг друга)
print_knot_length = 12;	 	// дополнительная длина строп на один узелы/cшивку петелек. используется только при расчете общей длины строп. рекомендуется 8-12 см в зависимости от нагрузки на стропу. прочность сшивки можно определить примерно как прочность_нитки * количество_стежков
// отступы на швы
print_LE = 1.5;			// отступ на шов по передней кромке верхнего полотнища, cм
print_TE = 1.5;			// отступ на шов по задней кромке верхнего полотнища, cм
print_sew = 1.5;		// отступ на шов для пришивания нервюр к верхней поверхности, cм
print_sew_rib = 1;		// отступ на шов для вшивания шнура по контуру нервюр, см
print_oval = {LE:10, TE:15, val:6};  // допуски на матрасность, LE - отступ в % от передней кромки (по умолчанию 10% хорды), TE - отступ от задней кромки (по умолчанию 15% хорды), val - на сколько увеличивается ширина полотнища (по умолчанию 6%)
// дополнительно
print_reper = 0;		// 0 - реперные точки по умолчанию (как продолжение строповки), иначе процент от общего числа точек в профиле
print_circle_size = 5;		// размер реперной точки, мм (по умолчанию 5 мм), уменьшайте если делаете кайт маленького размера и точки на шаблонах слишком большие
print_scale = 10;  	   	// единицы измерения при создании dxf файлов для печати, 1 - в сантиметрах, 10 - в миллиметрах, 0.01 - в метрах
print_up_level = 0;	 	// 0 - выводить длины верхнего яруса со всеми стропами, 1 - отдельно по нервюрам для V-строповки (только для 8 треугольников на нервюру), 2 - и там, и там


// настройки показа
opt_Draw_Half = 0;		// 0 - рисовать все крыло, 1 - только половину купола
opt_Show_Wing = 1;		// показывать купол
opt_Show_Nervures = 1;		// показывать нервюры
opt_Show_Bezier = 0;		// 1 - показать кривые безье и контрольные точки, 2 - только контрольные точки, 0 - не показывать
opt_Show_Polygons = 5;		// 1 и выше - показывать купол как полигональную поверхность, число определяет шаг при построении полигонов, чем больше шаг, тем меньше будет полигонов в модели (1 - используется каждая точка, 10 - через каждые 10 точек т.д.). рекомендуется 3-7
opt_Show_Rib_Polygons = 1;	// 1 - показывать полигональные треугольники, 0 - показывать только контур (можно отключить для ускорения расчета)
opt_Show_Ribs = 0;		// показывать выкройки нервюр в трехмерной модели (не для печати)
opt_Show_Panels = 0;		// показывать выкройки панелей в трехмерной модели (не для печати)

opt_Show_AB = 1;		// показывать строповку А,В на переднем конце
opt_Show_CD = 1;		// показывать строповку CD на заднем конце
opt_Show_Brakes = 1;		// показывать строповку клевант
opt_Show_CAX=0;	  		// показывать среднюю аэродинамическую хорду для крыла
opt_Show_Kite_Lines = 0;	// показывать основные кайтовые стропы (удлинители)

// другие настройки
opt_Scale_X = 1;		// масштаб крыла (исходных кривых безье) по размаху
opt_Scale_Y = 1;		// масштаб крыла по ширине
opt_Scale_Z = 1;		// масштаб арочности по высоте

opt_Rib_Scale = 1.8;		// масштаб арочности треугольников (1 - чистая парабола. 2 - касается верхней поверхности, по умолчанию 1.8)
opt_AoA_Twist = 2;		// 0 - линейно менять угол атаки к ушам, 1 - пропорционально хорде, 2 - пропорционально арочности (рекомендуется 2).
opt_Bezier_Step = 20;		// на сколько участков разбивать кривые безье при построении нервюр, чем больше тем плавнее кривая (рекомендуется не менее 20 участков, а лучше 50-100)
opt_Polyline_Step = 1;		// 1 - рисовать в полилиниях каждую точку, иначе с таким шагом для упрощения кривой (рекомендуется 1). при больших значениях форма контура может нарушаться

opt_eng = 0;  	// English - англ. язык при выводе bridles.txt


// --------------------------
// ФОРМА КУПОЛА И АРОЧНОСТЬ
// --------------------------

// кривые безье с 4 контрольными точками: x,y,z, x,y,z ... (координаты в см)
Bezier_LE = new Array(0,-100,0, 100,-100,0, 330,-80,0, 350,-20,0);
Bezier_TE = new Array(0,80,0, 100,80,0, 300,70,0, 350,30,0);
Bezier_AR = new Array(0,0,0, 90,0,0, 207,0,-33, 220,0,-133);


// для редактирования запустите editor.svg (откроется в вашем интернет браузере)
// и скопируйте сюда такие же по виду строки с новыми координатами



// --------------------------------------------------------------
// ДАЛЕЕ ИДЕТ ОСНОВНОЙ АЛГОРИТМ, НЕ ИЗМЕНЯТЬ
// --------------------------------------------------------------

// Примечание: AR начинается в начале координат и движется по положительной X и отрицательной Z. LE начинается на отрицательной оси Y, TE на положительной Y (так как профиль в XFLR5 носиком направлен влево). LE и TE лежат в плоскости XY.

// профиль х,у, х,у, ... начинается от задней кромки и идет по верхней поверхности. берется, например, из XFLR5
foil = new Array(1.00000,0.00000, 0.99547,0.00087, 0.98868,0.00218, 0.98188,0.00349, 0.97509,0.00479, 0.96829,0.00610, 0.96149,0.00740, 0.95470,0.00870, 0.94790,0.01000, 0.94110,0.01130, 0.93430,0.01260, 0.92751,0.01389, 0.92071,0.01519, 0.91391,0.01648, 0.90711,0.01777, 0.90031,0.01906, 0.89351,0.02035, 0.88671,0.02163, 0.87990,0.02291, 0.87310,0.02419, 0.86630,0.02546, 0.85950,0.02673, 0.85269,0.02800, 0.84589,0.02926, 0.83908,0.03052, 0.83228,0.03178, 0.82547,0.03303, 0.81866,0.03427, 0.81185,0.03551, 0.80504,0.03675, 0.79823,0.03798, 0.79142,0.03920, 0.78461,0.04042, 0.77779,0.04163, 0.77098,0.04284, 0.76416,0.04404, 0.75734,0.04523, 0.75052,0.04641, 0.74370,0.04759, 0.73688,0.04876, 0.73006,0.04992, 0.72323,0.05107, 0.71641,0.05222, 0.70958,0.05335, 0.70275,0.05448, 0.69592,0.05560, 0.68909,0.05670, 0.68226,0.05780, 0.67542,0.05889, 0.66859,0.05996, 0.66175,0.06103, 0.65491,0.06208, 0.64806,0.06312, 0.64122,0.06415, 0.63437,0.06517, 0.62753,0.06617, 0.62068,0.06716, 0.61383,0.06814, 0.60697,0.06910, 0.60012,0.07005, 0.59326,0.07099, 0.58640,0.07191, 0.57954,0.07282, 0.57268,0.07371, 0.56581,0.07459, 0.55894,0.07545, 0.55207,0.07630, 0.54520,0.07713, 0.53833,0.07794, 0.53146,0.07874, 0.52458,0.07953, 0.51770,0.08029, 0.51082,0.08105, 0.50394,0.08178, 0.49706,0.08250, 0.49017,0.08320, 0.48328,0.08389, 0.47640,0.08455, 0.46951,0.08520, 0.46261,0.08584, 0.45572,0.08645, 0.44882,0.08705, 0.44193,0.08762, 0.43503,0.08818, 0.42813,0.08872, 0.42123,0.08924, 0.41433,0.08974, 0.40742,0.09022, 0.40052,0.09068, 0.39361,0.09112, 0.38670,0.09153, 0.37979,0.09192, 0.37288,0.09229, 0.36597,0.09264, 0.35905,0.09296, 0.35214,0.09326, 0.34522,0.09353, 0.33831,0.09378, 0.33139,0.09400, 0.32447,0.09419, 0.31755,0.09436, 0.31063,0.09449, 0.30371,0.09459, 0.29679,0.09467, 0.28987,0.09471, 0.28295,0.09471, 0.27603,0.09468, 0.26911,0.09461, 0.26219,0.09451, 0.25527,0.09436, 0.24835,0.09417, 0.24144,0.09394, 0.23452,0.09366, 0.22761,0.09333, 0.22070,0.09296, 0.21379,0.09253, 0.20689,0.09205, 0.19999,0.09152, 0.19309,0.09093, 0.18620,0.09028, 0.17932,0.08957, 0.17244,0.08879, 0.16557,0.08795, 0.15871,0.08703, 0.15186,0.08604, 0.14502,0.08498, 0.13820,0.08383, 0.13139,0.08259, 0.12460,0.08126, 0.11783,0.07983, 0.11108,0.07830, 0.10436,0.07666, 0.09767,0.07489, 0.09101,0.07300, 0.08440,0.07096, 0.07783,0.06878, 0.07132,0.06642, 0.06489,0.06388, 0.05854,0.06114, 0.05229,0.05816, 0.04616,0.05494, 0.04020,0.05145, 0.03441,0.04766, 0.02883,0.04357, 0.02350,0.03917, 0.01847,0.03443, 0.01380,0.02934, 0.00956,0.02390, 0.00583,0.01810, 0.00279,0.01192, 0.00060,0.00540, 0.00026,-0.00139, 0.00341,-0.00747, 0.00837,-0.01222, 0.01432,-0.01568, 0.02082,-0.01796, 0.02758,-0.01940, 0.03441,-0.02037, 0.04128,-0.02112, 0.04817,-0.02169, 0.05507,-0.02197, 0.06198,-0.02197, 0.06889,-0.02174, 0.07577,-0.02132, 0.08264,-0.02080, 0.08957,-0.02029);


// если есть файл airfoil.dat, то читаем массив foil из него
fso1 = WScript.CreateObject("Scripting.FileSystemObject");
if (fso1.FileExists("airfoil.dat")) {
	f = fso1.OpenTextFile("airfoil.dat",1, false);			// чтение, не создавать
	f.ReadLine( );						   				   // первую строку пропускаем, там название профиля
	foil = new Array();
	while (!f.AtEndOfStream) {
	   	s = f.ReadLine();
		s = s.match(/[\-0-9\.]+/g);	// ищем только цифры вида -0.3445
		if (s!=null) {
			foil[foil.length] = s[0]*1;		// *1 - неявный перевод строки в число
			foil[foil.length] = s[1]*1;
			}
		}
	f.Close( );
	}


//-----------
// Обработка параметров командной строки (при запуске через GUI)

if (WScript.Arguments.length>0) {
	getArg();
	g_GUI = true;	// флаг, что это вызов из GUI через командную строку с параметрами
	} else g_GUI = false;


//WScript.echo("no");
//WScript.quit();



/*-----------
АЛГОРИТМ:

1. масштабируем профиль согласно толщине (макс. толщина к хорде)
2. находим в профиле точки LE, TE, точки для петелек, воздухозаборника и другие. пока просто ближайшие точки, в будущем надо сделать более точно делением отрезка пополам
3. разбиваем на сечения с равными расстояниями по арочности, находим хорду из le и te (методом деления отрезка  пополам, т.к. параметр t не только не совпадает у разных кривых, но еще и неравномерно идет вдоль кривой)
4. масштабируем толщину и длину профиля. толщину интерполируем линейно согласно настройкам, длину по хорде
5. поворачиваем на угол атаки согласно аэр.качеству и положительной крутке
6. поворачиваем перпендикулярно арочности (для лобика, треуг.нервюры потом повернем вдоль строповки)
7. расчет САХ и определение точки подвеса
8. расчет строповки, для каждого яруса определяются все точки, которые ему принадлежат, и находится средняя арифметическая среди них. отрезок направляется к ней, а после укорачивается на длину яруса (для свободных концов на заданное расстояние в см, а остальные в процентах высоты яруса)
9. укорачиваем верхнюю строповку на длину треугольников аналогично укорачиванию отрезков ярусов, но проценты относительно текущей хорды.
10. от концов строп по расстоянию рисуем безье с тремя точками: первая и третья на петельках, а средняя на верхней поверхности между петельками. при этом средний отрезок масштабируем в 1.8 раз, чтобы увеличить арочность кривой безье, так как по умолчанию парабола слишком низкая

Печать:
1. из трехмерной модели берем длины треугльников и поворачиваем их до вертикального положения, а потом рисуем кривые безье аналогично как для трехмерной модели
2. на нервюры добавляем реперные точки (куда должно придти продолжение строповки верхнего яруса) и припуск на швы путем поворачивания отрезка длиной в шов на 90 градусов
3. верхние панели строим триангуляцией на основе длин отрезков между соседними нервюрами
4. добавляем припуск на матрасность, до указанных процентов хорды увеличиваем линейно, а потом постоянное расстояние. технически сделано через функции создания припуска на шов, только ширина шва как бы переменная
5. добавляем припуск на швы поверх матрасности и отмечаем реперные точки, аналогичные тем что были на нервюрах
6. в итоге для всех нервюр и полотен создаются массивы с точками, которые потом печатаются как полилинии

ВНИМАНИЕ! описание алгоритма может быть неточным, так как после последних модификаций оно не редактировалось

*/



// служебные переменные
foils = new Array();    			// массив сечений, каждое состоит из массива объектов-точек p = {x:1, y:2, z:0};
LE=0; 		  						// индекс точки носика профиля
TE=0; 		  						// индекс точки задней кромки профиля
MID=0;		  			 			// точка 25% профиля для вращения на угол атаки (может посередине?)
VENT=0;		  			 			// точка начала воздухозаборника, она же точка окончания верхнего полотнища, которое идет от TE до VENT
A0=0; 		 						// точка на верхней части лобика, от которой идет вшитый шнур к первой петельке А
L0=0; 		 						// точка на верхней части лобика, от которой начинается леска
REPER1 = 0;	 						// дополнительная реперная точка на лобике нервюры
REPER2 = 0;	 						// дополнительная реперная точка на лобике нервюры

OL = 0;	 							// индекс начала матрасности (овализации) для передней кромки
OT = 0;	 							// индекс начала матрасности (овализации) для задней кромки


// добавим любому массиву метод .add, обязательно до первого использования
Array.prototype.add = function (p,y,z) {		// добавляет в конец любого массива точку p{x,y,z} или (x,y,z) (зависит от количества элементов
 if (arguments.length==1) this[this.length]={x:p.x, y:p.y, z:p.z};  	   // копируем точку, чтобы не создавалась ссылка
    else this[this.length]={x:p, y:y, z:z};		   		   	   		 	   // x,y,z заданы в явном виде
 }
 //----

// преобразуем профиль в набор точек P{x,y,z}
foiln = new Array();
for(i=0;i<foil.length;i+=2) foiln[foiln.length]={x:foil[i], y:foil[i+1], z:0};
foil = foiln;
VENT=foil.length-1;				// VENT - индекс окончания верхнего полотнища (в нашем случае конец массива)
REPER1 = Math.round(91.9*foil.length/100);	// дополнительная реперная точка на 8.1% длины нервюры (для других профилей надо подбирать другие проценты)
REPER2 = Math.round(82*foil.length/100);	// дополнительная реперная точка на 18% длины нервюры


// обрабатываем профиль
chord=0;		// длина хорды
ymax=-9999;
ymin=9999;
for (i=0;i<foil.length;i++) {
	tmp=foil[TE].x-foil[i].x;
	if (tmp>=chord) {chord=tmp; LE=i;}		// LE определяет индекс точки носика, т.е. с максимальной длиной
	// ищем мин. и макс. y для определения толщины профиля
	if (foil[i].y>ymax) ymax=foil[i].y;
	if (foil[i].y<ymin) ymin=foil[i].y;
	}
foil.chord=chord;					// запоминаем хорду исходного профиля
foil.camber=(ymax-ymin)*100/chord;			// толщина профиля в %


// сдвигаем профиль чтобы в 0,0 находился хвостик и по высоте на высоту профиля, чтобы ширина секций считалась правильнее (не увеличивалась к ушам из-за кривизны профиля)
dx=foil[TE].x;
dy=foil[TE].y+ymax;
foil.dy=dy;						// запоминаем смещение по вертикали
for(i=0;i<foil.length;i++) {
	foil[i].x = foil[i].x - dx;
	foil[i].y = foil[i].y - dy;
	}


// проверим, что макс. x у LE и TE были не меньше, чем у AR (иначе метод деления отрезка не будет работать ниже)
/*
if (Bezier_LE[3*3]<Bezier_AR[3*3]) Bezier_LE[3*3]=Bezier_AR[3*3];
if (Bezier_TE[3*3]<Bezier_AR[3*3]) Bezier_TE[3*3]=Bezier_AR[3*3];
if (Bezier_LE[0]>Bezier_AR[0]) Bezier_LE[0]=Bezier_AR[0];
if (Bezier_TE[0]>Bezier_AR[0]) Bezier_TE[0]=Bezier_AR[0];
*/
// AR должна быть всегда из центра координат, а LE и TE начинаться  оси Y
Bezier_AR[0]=0;Bezier_AR[1]=0;Bezier_AR[2]=0;
Bezier_LE[0]=0;	 // х первой точки всегда 0
Bezier_LE[2]=0;	 // z первой точки всегда 0
Bezier_TE[0]=0;
Bezier_TE[2]=0;


// масштабируем кривые безье по x и y
for(i=0;i<4;i++) {
	Bezier_LE[i*3]=Bezier_LE[i*3]*opt_Scale_X;
	Bezier_LE[i*3+1]=Bezier_LE[i*3+1]*opt_Scale_Y;

	Bezier_TE[i*3]=Bezier_TE[i*3]*opt_Scale_X;
	Bezier_TE[i*3+1]=Bezier_TE[i*3+1]*opt_Scale_Y;

	Bezier_AR[i*3]=Bezier_AR[i*3]*opt_Scale_X;
	Bezier_AR[i*3+2]=Bezier_AR[i*3+2]*opt_Scale_Z;
	}


// масштабируем крыло чтобы оно соответствовало площади и удлинению
// FIX: довольно дурацкий алгоритм, сначала изменяем ширину крыла, чтобы соответствовало удлинению, потом ищем делением отрезка пополам площадь,
// но при этом из-за кривых безье изменится удлинение. поэтому в конце еще раз корректируем удлинение (но площадь опять изменится немного)
a = calc_area();

if (opt_AR) {
	// сначала масштабируем удлинение
	k=a.AR/opt_AR;
	// масштабируем только ширину крыла
	for (i=0;i<4;i++) {
		Bezier_LE[i*3+1]=Bezier_LE[i*3+1]*k;	// y
		Bezier_TE[i*3+1]=Bezier_TE[i*3+1]*k;	// y
		}

	// снова определяем площадь крыла и удлинение
	a = calc_area();
	}

if (opt_Area) {
	// масштабируем площадь крыла делением отрезка пополам
	ble = new Array();
	bte = new Array();
	bar = new Array();
	for (i=0;i<Bezier_LE.length;i++) {
		ble[i]=Bezier_LE[i];
		bte[i]=Bezier_TE[i];
		bar[i]=Bezier_AR[i];
		}
	k1=0.01;k2=100; k = (k1+k2)/2;
	while(Math.abs(a.S-opt_Area)>0.01) {
		for (i=0;i<4;i++) {
			Bezier_LE[i*3]=ble[i*3]*k;		// x
			Bezier_LE[i*3+1]=ble[i*3+1]*k;	// y
			Bezier_TE[i*3]=bte[i*3]*k;		// x
			Bezier_TE[i*3+1]=bte[i*3+1]*k;	// y
			Bezier_AR[i*3]=bar[i*3]*k;		// x
			Bezier_AR[i*3+2]=bar[i*3+2]*k;	// z
			}

		// проверка
		a = calc_area();
		if (a.S<opt_Area) {k1=k; k = (k1+k2)/2;} else {k2=k; k = (k1+k2)/2;}	// площадь переводим в м2
		}
	// второй раз корректируем удлинение
	if (opt_AR) {
		k=a.AR/opt_AR;
		// масштабируем только ширину крыла
		for (i=0;i<4;i++) {
			Bezier_LE[i*3+1]=Bezier_LE[i*3+1]*k;	// y
			Bezier_TE[i*3+1]=Bezier_TE[i*3+1]*k;	// y
			}
		// снова определяем площадь крыла и удлинение
		a = calc_area();
		}
}

function len_AR() {
		// возвращает длину арочности и корректирует размер LE и TE если нужно
		// найдем длину кривой арочности с шагом около 0.5 см (1000 точек, 1/5000=0.001).  FIX: надо бы динамически определять в зависимости от размера крыла
		var len=0; var x=0; var z=0;var x_prev=0; var z_prev=0;
		for(t=0;t<=1;t+=0.001) {
			x = bezier(Bezier_AR,t,"x");	// и переносим отрезок в начало координат
			z = bezier(Bezier_AR,t,"z");
			len+=Math.sqrt((x-x_prev)*(x-x_prev)+(z-z_prev)*(z-z_prev));		// длина вектора sqrt(x^2+y^2)
			x_prev=x;
			z_prev=z;
			}

		// всегда масштабируем LE и TE по длине, чтобы они соответствовали длине арочности
		x = bezier(Bezier_LE,1,"x");
		if (1) {//x<len
			var k=(len+1)/x;	// +1 см запаса на погрешность определения длина арочности
			// по всем контрольным точка, кроме начальной
			for (i=3;i<Bezier_LE.length;i+=3) {
				Bezier_LE[i]=Bezier_LE[i]*k;	// 1 см запаса на погрешность определения длины AR
				}
			}
		x = bezier(Bezier_TE,1,"x");
		if (1) {//x<len
			var k=(len+1)/x;	// +1 см запаса на погрешность определения длина арочности
			// по всем контрольным точка, кроме начальной
			for (i=3;i<Bezier_TE.length;i+=3) {
				Bezier_TE[i]=Bezier_TE[i]*k;	// 1 см запаса на погрешность определения длины AR
				}
			}

		return len;
		}

function tri_area(L1,L2,R1,R2) {
	// площадь двух треугольников 	S = Math.sqrt(p*(p-a)*(p-b)*(p-c)); p = (a+b+c)/2;
	var a = pdist(L1,R1);
	var b = pdist(L2,R1);
	var c = pdist(L1,L2);
	var p = (a+b+c)/2;
	var S = Math.sqrt(p*(p-a)*(p-b)*(p-c));
	// второй треугольник
	a = pdist(L2,R2);
	b = pdist(L2,R1);
	c = pdist(R1,R2);
	p = (a+b+c)/2;
	S += Math.sqrt(p*(p-a)*(p-b)*(p-c));
	return S;
	}
function calc_area() {
		// возвращает плоскую площадь, плоский размах и плоское удлинение {S,l,AR};
		var S = 0;
		var l=0;
		var x1 = bezier(Bezier_AR,0,"x"); var x2;
		var z1 = bezier(Bezier_AR,0,"z"); var z2;
		var L1=bezier(Bezier_LE,0); L1.z=z1;
		var R1=bezier(Bezier_TE,0); R1.z=z1;
		var L2; var R2;
		var dx; var t1; var t2; var x;

		var len = len_AR();	// длина арочности

		var step=1/50;								// на 50 разбиений (по 10 см)
		var num=1;
		for (t=step;t<=1;t=num*step) {
			num++;

			// считаем через площади треугольников
			x2 = bezier(Bezier_AR,t,"x");
			z2 = bezier(Bezier_AR,t,"z");
			l+= dist(x1,0,z1, x2,0,z2);				// тек. длина арочности

			if (Bezier_LE[3*3]<l) Bezier_LE[3*3]=l;	   // удлиняем крыло по x, чтобы плоский вид сверху был не короче длины арочности
			if (Bezier_TE[3*3]<l) Bezier_TE[3*3]=l;

			L2 = {x:x2, y:0, z:z2};
			R2 = {x:x2, y:0, z:z2};

			// ищем L1.y и R2.y у LE и TE для текущей длины арочности делением отрезка пополам
			dx=0.5;								// с точностью 1 см  FIX: хорошо бы точность подбирать динамически. почему-то 0.5 и ниже зависает
			t1=0;t2=1;tt=0.5;
			x = bezier(Bezier_LE,tt,"x");
			while(Math.abs(x-l)>dx) {
				if (x<l) {t1=tt;tt=(t1+t2)/2;} else {t2=tt;tt=(t1+t2)/2;}
				x = bezier(Bezier_LE,tt,"x");
				}
			L2.y = bezier(Bezier_LE,tt,"y");

			t1=0;t2=1;tt=0.5;
			x = bezier(Bezier_TE,tt,"x");
			while(Math.abs(x-l)>dx) {
				if (x<l) {t1=tt;tt=(t1+t2)/2;} else {t2=tt;tt=(t1+t2)/2;}
				x = bezier(Bezier_TE,tt,"x");
				}
			R2.y = bezier(Bezier_TE,tt,"y");

			S+=tri_area(L1,L2,R1,R2);				// площадь двух треугольников

			L1=L2;
			R1=R2;
			x1=x2;
			z1=z2;
			}
		S*=2;			// для двух полукрыльев
		l*=2;
		// удлинение
		var AR = l*l/S;
		S=S/10000;		// переводим в метры
		return {S:S, l:l, AR:AR};
		}

// --------------------------------------------------------------
// СОЗДАЕМ СЕЧЕНИЯ
// --------------------------------------------------------------

len = len_AR();
foils.wingspan = len*2;			// размах крыла на земле


// приводим к нечетному числу секций если четное
if (((opt_Cells/2)+"").indexOf(".")==-1) opt_Cells++;


// количество сечений на одном полукрыле
opt_Cells = (opt_Cells-1)/2;


////////////////////////////////////////////////////////////
// FIX!!!!!
////////////////////////////////////////////////////////////

nnn=opt_Tip_Width;  	// 0.8			// ширина ушей меньше ширины центральной секции
nnn=2-nnn;				// 0.8 -> 1.2
nnn2=(nnn-1)*2;	   		// 2*0.2 = 0.4
nnn2=1-nnn2/(opt_Cells+2);  // +2 при разном коэфф. надо менять


// расстояния между нервюрами
step_mid=(len*2/(opt_Cells*2+1))*nnn;				// среднее расстояние между секциями
step1 = step_mid/2;							// половина ширины центральной секции      FIX: можно в настройках ширину центральной секции сделать настраиваемой
step2 = step1*2;								// ширина остальных секций		   FIX: можно в настройках шаг сделать уменьшаюшимся к ушам (пропорционально хорде)


foils.cell_width = step_mid;
t_prev=0;

ribs = new Array();					// плоские нервюры для печати
xlen=0;	   // длина арочности до тек. секции

// по всем сечениям...
for(ind=0;ind<=opt_Cells;ind++) {
	p=new Array();
	for(i=0;i<foil.length;i++) p[i]={x:0, y:foil[i].x, z:foil[i].y};// создаем копию профиля, которую будем далее изменять. массив точек профиля P{x,y,z}

	// ТОЛЩИНА ПРОФИЛЯ

	// линейная интерполяция // t = (x - L) / (R - L), f(t) = (1 - t) f(L) + t f(R)
	t = (ind-0)/(opt_Cells-0);
	t = (1-t)*opt_Camber_Center + t*opt_Camber_Tip;
	k = t / foil.camber;						// коэфф. на сколько нужно изменить толщину профиля
	for(i=0;i<p.length;i++) p[i].z = p[i].z*k;
	p.camber = foil.camber*k;

	// ПОЛОЖЕНИЕ ПРОФИЛЯ

	// параметр t для текущей секции по арочности Bezier_AR
	//t=ind/opt_Cells;						// СТАРЫЙ ВАРИАНТ, было не равное расстояние между секциями


	// НОВЫЙ ВАРИАНТ, увеличиваем длину короткими шагами, пока не найдем нужную длину отрезка между секциями

	// если ширина секций уменьшается к ушам, то изменим параметр step2 - ширину тек. секции
	if (opt_Tip_Width!=100 && ind>0) {
		step2*=nnn2;
		}


	len=0; x_prev=0;z_prev=0;
	t = t_prev;
	x_prev = bezier(Bezier_AR,t,"x");
	z_prev = bezier(Bezier_AR,t,"z");

	if (ind==0) step=step1; else step=step2;
	while(len<step) {
		t+=0.0002;						// увеличиваем длину на 1 мм. FIX: надо бы динамически определять в зависимости от размера крыла
		if (t>1) t=1;
		x = bezier(Bezier_AR,t,"x");
		z = bezier(Bezier_AR,t,"z");
		len+=Math.sqrt((x-x_prev)*(x-x_prev)+(z-z_prev)*(z-z_prev));
		x_prev=x;
		z_prev=z;
		if (t==1)  break;
		}
	t_prev=t;
	xlen+=len;							// длина арочности до тек. секции


	// определим положение сечения на кривой арочности
 	p.x = bezier(Bezier_AR,t,"x");
	p.z = bezier(Bezier_AR,t,"z");
	t_p = t;	// запомним t=0..1 на кривой арочности, понадобится ниже

	// хорда - расстояние между LE и TE в точке t
	//yle = Math.abs(bezier(Bezier_LE,t,"y"));			// СТАРЫЙ ВАРИАНТ, хорда не точно укладывалась между кривыми LE и TE
	//yte = Math.abs(bezier(Bezier_TE,t,"y"));


	// НОВЫЙ ВАРИАНТ, ищем делением отрезка пополам t, координата x которого соответствует текущей длине арочности (не х арочности, а длине! т.к. при виде сверху плоский раскрой. иначе при углах арочности больше 90 градусов хорда начнет увеличиваться в обратную сторону)

	dx=0.5;								// с точностью 1 см  FIX: хорошо бы точность подбирать динамически. почему-то 0.5 и ниже зависает
	t1=0;t2=1;t=0.5;
	x = bezier(Bezier_LE,t,"x");

	while(Math.abs(x-xlen)>dx) {
		if (x<xlen) {t1=t;t=(t1+t2)/2;} else {t2=t;t=(t1+t2)/2;}
		x = bezier(Bezier_LE,t,"x");
		}
	yle = bezier(Bezier_LE,t,"y");

	t1=0;t2=1;t=0.5;
	x = bezier(Bezier_TE,t,"x");
	while(Math.abs(x-xlen)>dx) {
		if (x<xlen) {t1=t;t=(t1+t2)/2;} else {t2=t;t=(t1+t2)/2;}
		x = bezier(Bezier_TE,t,"x");
		}
	yte = bezier(Bezier_TE,t,"y");			// FIX: здесь где-то ошибка, если задать yte=50; yle=-50; то не получается прямоугольного крыла, передняя кромка сдвинута вперед

	tchord = yte-yle;						// FIX: x может не соответствовать x арочности, в будущем можно сделать точнее
	k=tchord/foil.chord;						// коэфф. на сколько изменить хорду оригинального профиля, чтобы он вписался в ширину текущей секции

	// запоминаем смещение профиля по y и хорду
	p.y=yte;
	p.chord=tchord;

	// масштабируем профиль и смещаем его на свое место вдоль арочности
	for(i=0;i<p.length;i++) {p[i].x=p.x; p[i].y=p[i].y*k+p.y; p[i].z=p[i].z*k+p.z;}


	// УГОЛ АТАКИ

	if (opt_AoA_Twist==0) {
		// линейная интерполяция крутки к ушам t = (x - L) / (R - L), f(t) = (1 - t) f(L) + t f(R)
		t = ind/opt_Cells;
		t = (1-t)*opt_AoA + t*(opt_AoA+opt_AoA_Tips);	// сумма, т.к. в pt_AoA_Tips не угол, а крутка дополнительная к основному углу
		} else if (opt_AoA_Twist==1) {
			// пропорционально хорде, более правильный вариант
			chord_root = bezier(Bezier_TE,0,"y")-bezier(Bezier_LE,0,"y");
			chord_tip = bezier(Bezier_TE,1,"y")-bezier(Bezier_LE,1,"y");
			t = (p.chord-chord_root)/(chord_tip-chord_root);
			t = (1-t)*opt_AoA + t*(opt_AoA+opt_AoA_Tips);
			} else {
				// пропорционально арочности, самый правильный вариант
				a_root=0;			   // угол арочности (угол между горизонтом и отрезком по кривой арочности до пред. секции) в центре, град
				t_p-=1/opt_Cells;  	   // t пред. секции (примерно, реальное брать не можем, так как для уха еще не знаем где будет пред. секция)
				if (t_p<0) t_p=0;
				a_curr = fangle(p.x,0,p.z, p.x-20,0,p.z, bezier(Bezier_AR,t_p,"x"),0,bezier(Bezier_AR,t_p,"z"))*180/Math.PI;	// угол арочности на тек. сечении, град
				tmpx=bezier(Bezier_AR,1,"x");
				tmpz=bezier(Bezier_AR,1,"z");
				tmpt=1-1/opt_Cells;
				a_tip = fangle(tmpx,0,tmpz, tmpx-20,0,tmpz, bezier(Bezier_AR,tmpt,"x"),0,bezier(Bezier_AR,tmpt,"z"))*180/Math.PI;	// угол арочности на ухе, град

				t = (a_curr-a_root)/(a_tip-a_root);
				t = (1-t)*opt_AoA + t*(opt_AoA+opt_AoA_Tips);
				}

	// угол атаки относительно горизонта находится по формуле a-arctan(1/K), где а - угол атаки в полете, К - аэродинамическое качество
	angle = t - Math.atan(1/opt_K)*180/Math.PI;		// atan возвращает в радианах, поэтому переводим в градусы град = рад*180/3.14
	p.angle=angle;						// запоминаем угол в сечении


	// теперь поворачиваем все сечение на угол атаки. Угол для sin/cos надо переводить в радианы! рад=(пи/180)*градусы
	// FIX: поворот делается относительно середины профиля, так как профиль уже отцентрован по осям координат
	angle = -(Math.PI / 180.0) * angle;
	for (i = 0; i < foil.length; i++) {
		x=p[i].y; y=p[i].z;
		p[i].y = x * Math.cos(angle) - y * Math.sin(angle);	// реально изменяются y и z
		p[i].z = x * Math.sin(angle) + y * Math.cos(angle);
		}


	// сохраним плоский профиль для последующей печати нервюр, TE в центре координат
	// ВНИМАНИЕ! сохранять обязательно после поворота на угол атаки, так как приведение к вертикальным нервюркам мы делаем поворотом треугольников на уже повернутом на угол атаки трехмерном профиле
	ribs[ind] = new Array();
	for(i=0;i<p.length;i++) ribs[ind][i] = {x:p[i].x-p[TE].x, y:p[i].y-p[TE].y, z:p[i].z-p[TE].z};
	ribs[ind].chord=p.chord;
	ribs[ind].camber=p.camber;


	// ПЕРПЕНДИКУЛЯРНО АРОЧНОСТИ

	// повернем перпендикулярно арочности (на угол отрезка от пред.секции до тек.)
	// переносим пред. секцию в начало координат
	x=p.x; y=p.z;
	if (ind>0) {x-=foils[ind-1].x; y-=foils[ind-1].z;}
	if (x==0) a = 45; else a = Math.atan(y/x);
	a = a * 180/Math.PI;			// и переводим в градусы
	if (x<0) a = 180+(180-a);  		// когда угол арочности больше 90 градусов
	p.angle_AR = a;				// запоминаем угол в сечении
	a = (Math.PI / 180.0) * a;		// и переводим обратно в радианы

	// поворачиваем...
	for (i = 0; i < foil.length; i++) {
		x=p[i].x - p.x; y=p[i].z - p.z;				// смещаем профиль в начало координат (-p.x)
		p[i].x = x * Math.cos(a) - y * Math.sin(a) + p.x;	// реально изменяются x и z, и восстанавливаем положение профиля (+p.x)
		p[i].z = x * Math.sin(a) + y * Math.cos(a) + p.z;
		}


	foils[ind]=p;
	}

// проекционный размах
foils.wingspan_proj = foils[foils.length-1].x*2;	// cm

//WScript.echo("ok");



// --------------------------------------------------------------
// РАСЧЕТ САХ   FIX: в целом, правильно. только не очень совпадает по длине
// --------------------------------------------------------------

// служебные суммы для всех секций, требуются для расчета общей САХ крыла
sumb=0;
sumx=0;
sumy=0;
sums=0;

// созданим массив в виде x,y,y2, x,y,y2
// первую вертикальную линию добавим вручную, так как по центру у нас сплошная секция
arr = new Array();
arr[0]=0;
arr[1]=foils[0][LE].y;
arr[2]=foils[0][TE].y;

for (i=0;i<foils.length;i++) {
	arr[arr.length]=foils[i].x;
	arr[arr.length]=foils[i][LE].y;
	arr[arr.length]=foils[i][TE].y;
	}

// число секций
num = (arr.length-3)/3;

// сместим носик центральной хорды в начало координат
dx = arr[0];
dy = arr[1];
for (i=0;i<arr.length;i+=3) {
	arr[i]=arr[i]-dx;
	arr[i+1]=arr[i+1]-dy;
	arr[i+2]=arr[i+2]-dy;
	}

// для каждой секции найдем местные САХ
for (i=0;i<num;i++) {
	n=i*3;			// начало текущей секции
	// x,y,y2, x,y,y2
	x = arr[n];		// начальная хорда
	y = arr[n+1];
	y2 = arr[n+2];
	xk = arr[n+3];		// конечная хорда
	yk = arr[n+3+1];
	yk2 = arr[n+3+2];

	b0 = y2-y;				// длина начальной хорды
	bk = yk2-yk;				// длина концевой хорды
	l = (xk-x)*2;				// размах крыла для тек. секции

	b = (b0+bk-(b0*bk/(b0+bk)))*2/3;	// длина САХ для текущей трапеции
	xb = (l/6)*((b0+2*bk)/(b0+bk))+x;	// расстояние до центральной хорды, поэтому +x. l - размах крыла (а не единица)
	yb = ((b0+2*bk)/(b0+bk))*((yk-y)/3) + (y-arr[1]);	// отступ носика САХ от носика центральной хорды, поэтому нужно добавлять смещение до центральной
	s = (b0+bk)*(xk-x)/2;			// площадь тек. трапеции. S = (a+b)*h/2

	// служебные суммы
	sums += s;
	sumb += b*s;
	sumx += xb*s;
	sumy += yb*s;

	}//for

// теперь найдем общую САХ и ее положение
b = Math.round(sumb/sums);
x = Math.round(sumx/sums);
y = Math.round(sumy/sums);
// найдем проекцию центра давления, расположенного на САХ, на центральную хорду (нужно для Surfplan)
tow = b*opt_CoP/100 + y;
tow = (tow)*100/(arr[2]-arr[1]);

foils.CAX={x1:(x+dx), y1:(y+dy), x2:(x+dx), y2:(y+dy+b), len:b, CAX_Center:tow};	// CAX_Center: % на центральной хорде
foils.area_proj = sums*2/10000;	// площадь обоих полукрыльев, м2

l=foils.wingspan_proj/100;
foils.AR_proj = l*l/foils.area_proj;

a = calc_area();
foils.area = a.S;
foils.AR = a.AR;

//WScript.echo("CAX: длина "+b+", смещение от носика центральной хорды: x="+x+", y="+y+"\n\n"+"Положение САХ на картинке: нарисуйте линию от координат ("+(x+dx)+","+(y+dy)+") до ("+(x+dx)+","+(y+dy+b)+")\n\n"+opt_CoP+"% САХ = "+tow+"% на центральной хорде\n\n"+"Таким образом, в Surfplan надо вводить towpoint "+tow+"%");
//WScript.echo("Площадь "+trim(foils.area)+" м2\nУдлинение "+trim(foils.AR)+"\nРазмах "+trim(foils.wingspan/100)+" м\n\nПроекц. площадь "+trim(foils.area_proj)+" м2\nПроекц. удлинение "+trim(foils.AR_proj)+"\nПроекц. размах "+trim(foils.wingspan_proj/100)+" м");




// --------------------------------------------------------------
// СТРОПОВКА
// --------------------------------------------------------------
if (!opt_8p) opt_8p=2;	// по умолчанию по 4 треугольника
opt_Rib_Skip=1;			// пропустить создание треугольничков для стольких строп (т.е. они будут подсоединены напрямую к лобику)


bridle = new Array();
bridle.ribs = new Array();	// все стропы верхнего яруса на всех нервюрах, включая клевантные
// по всем нервюрам
for (n=0;n<foils.length;n++) {
	bridle.ribs[n] = new Array();
	// по всем точкам петелек, включая заднюю кромку для клевант создадим пустые объекты
	for (i=0; i<(8/opt_8p)+1; i++) bridle.ribs[n][i]=null;		// +1, т.к. включая точку клевант. объект (p1,p2,p) будет создан при расчете строповки. p1 - общая точка, p2 - на верхней поверхности, p - укороченная точка в вершине треугольника
	}


// первая петелька всегда должна быть не дальше по хорде, чем заканчивается носик
tmp=(foil[VENT].x-foil[LE].x)*100/(foil[TE].x-foil[LE].x);	  // % конца носика на хорде от LE
if (opt_Bridle_Points[0]>tmp) opt_Bridle_Points[0]=tmp;	  	  // ставим где заканчивается носик, если первая петелька выступала за него

// проверим, чтобы не было случайно заданы 4 точки вместо 8. тогда зададим равномерно распределение между первой и последней
if (opt_8p==1 && opt_Bridle_Points.length<8 || opt_8p==2 && opt_Bridle_Points.length>4) {
	opt_Bridle_Points = new Array(opt_Bridle_Points[0],opt_Bridle_Points[opt_Bridle_Points.length-1]);
	}


// зададим равномерное распределение, если указан только диапазон
if (opt_Bridle_Points.length==2) {
	min=opt_Bridle_Points[0]; max=opt_Bridle_Points[1];
	for (n=0,i=min;n<8/opt_8p;i+=(max-min)/(8/opt_8p-1), n++) opt_Bridle_Points[n]=i;
	}




// найдем индексы точек для строп, начиная с передней кромки
bridle.points = new Array();
for (p=0;p<opt_Bridle_Points.length;p++) {
	b=0;  // на нижней поверхности?
	for (i=0;i<foil.length;i++) {
		// идем от хвостика, как только процент превысит или равен, это точка на верхней поверхности. а если потом станет меньше, то это на нижней поверхности
		x = (foil[i].x-foil[LE].x)*100/(foil[TE].x-foil[LE].x);	// текущие проценты хорды
		if (b && (x>=opt_Bridle_Points[p] || p<opt_Rib_Skip && i==foil.length-1)) {bridle.points[p]=i; break;}		// на нижней поверхности, сначала эта строка, т.к. проверка на =
		if (!b && x<=opt_Bridle_Points[p]) {bridle.points[p]=i; b=true;}
		}
	}

// найдем середины между точками для строп, начиная с передней кромки
bridle.mpoints = new Array();
for (n=0;n<bridle.points.length;n++) {
	p1 = foil[bridle.points[n]];
	if (n==bridle.points.length-1) p2=foil[TE]; else p2=foil[bridle.points[n+1]];	// последняя точка всегда задняя кромка TУ
	//x = pdist(p2,p1)/2+p1.x;	// точка на середине отрезка между точками
	x = (p2.x+p1.x)/2;	// точка на середине отрезка между точками

	// по всем точкам профиля
	for (i=0;i<foil.length;i++) {
		// идем от хвостика, как только тек. точка станет меньше или равно х, то выходим
		//if (foil[i].x<=x) {bridle.mpoints[n]=i-1;break;}
		if (foil[i].x<=x) {
			// определим какая точка ближе к середине отрезка, текущая или предыдущая
			if (foil[i].x-x < foil[i-1].x-x) bridle.mpoints[n]=i-1; else bridle.mpoints[n]=i;
			break;
			}
		}
	}

// найдет индекс А0, с которого начинается вшитый шнур
for (i=0;i<foil.length;i++) {
	// идем от хвостика по верхней поверхности
	x = (foil[i].x-foil[LE].x)*100/(foil[TE].x-foil[LE].x);	// текущие проценты хорды от носика
	if (x<=opt_Bridle_A0) {A0=i;break;}
	}

// найдет индекс L0, с которого начинается леска в лобике нервюры
for (i=0;i<foil.length;i++) {
	// идем от хвостика по верхней поверхности
	x = (foil[i].x-foil[LE].x)*100/(foil[TE].x-foil[LE].x);	// текущие проценты хорды от носика
	if (x<=opt_Bridle_L0) {L0=i;break;}
	}

// найдем индекс OL, с которого начинается овализация на лобике нервюры
for (i=0;i<foil.length;i++) {
	// идем от хвостика по верхней поверхности
	x = (foil[i].x-foil[LE].x)*100/(foil[TE].x-foil[LE].x);	// текущие проценты хорды от носика
	if (x<=print_oval.LE) {OL=i;break;}
	}
// найдем индекс OT, с которого начинается овализация на хвостике  нервюры
for (i=0;i<foil.length;i++) {
	// идем от хвостика по верхней поверхности
	x = (foil[i].x-foil[LE].x)*100/(foil[TE].x-foil[LE].x);	// текущие проценты хорды от носика
	if (x<=100-print_oval.TE) {OT=i;break;}
	}



// основная идея строповки: ищем среднее положение всех точек, а после укорачиваем отрезок до этой точки в заданном процентном соотношение
// идем снизу вверх, каждый блок расчета принимает в качестве начальной точки результат пред. расчета

arr = new Array();	// arr[передний конец][A|B][размах][средний ярус][верхний ярус].p,p1, arr[задний конец][размах][A|B][средний ярус][верхний ярус].p,p1, arr[клеванты][нижний ярус][средний ярус][верхний ярус].p



// найдем точки схождения свободных концов 40 см, высота от размаха
// для параплана, спидглайдера...
tmp_x=opt_Bridle_Riser_Dist/2;
tmp_y=foils[0].chord*foils.CAX.CAX_Center/100+foils[0][LE].y;
tmp_z=-(opt_Bridle_Height*foils.wingspan/100);

// для кайта найдем расстояние между свободными концами автоматически
if (opt_Kite_Lines) {

	opt_Kite_Lines = opt_Kite_Lines*100;	// переводим в см
	tmp_zk = tmp_z-opt_Kite_Lines;			// добавляем по высоте длину основных строп кайта
	arr.p0 = {x:tmp_x, y:tmp_y, z:tmp_zk};	// точка карабина для кайта

	// алгоритм как при расчете строповки - находим среднюю точку всех петелек и проводим туда отрезок, потом укорачиваем его длину на длину свободных концов

	p1 = arr.p0;	// начальная точка

	sum_x=0;sum_y=0;sum_z=0;num=0;
	// все полукрыло с 8 точками вдоль хорды
	for (n=0;n<foils.length;n++) for(i=0;i<8/opt_8p;i++) {
		sum_x+=foils[n][bridle.points[i]].x;
		sum_y+=foils[n][bridle.points[i]].y;
		sum_z+=foils[n][bridle.points[i]].z;
		num++;
		}
	p = {x:sum_x/num, y:sum_y/num, z:sum_z/num};	// отрезок до средней точки
	len = pdist(p1,p);

	// укорачиваем отрезок до длины основных линий кайта конца по формуле: x = (x1+l*x2)/(1+l); где l = соотношение нижней к верхней длине подотрезков, например l=8:1
	l = opt_Kite_Lines;	// cm
	l = l/(len-l);
	p.x = (p1.x+l*p.x)/(1+l);
	p.y = (p1.y+l*p.y)/(1+l);
	p.z = (p1.z+l*p.z)/(1+l);

	// замещаем x и y на конец кайтовых основных строп
	tmp_x=p.x;
	tmp_y=p.y;
	tmp_z=p.z;
	}


bridle.origin = {x:tmp_x, y:tmp_y, z:tmp_z};
if (!opt_Kite_Lines) arr.p0=bridle.origin;	// точка схождения клевант (точка карабина) одинаковая для кайта и параплана (чтобы была универсальная)


// массив по нервюрам для верхнего яруса


// свободные концы
for (r=0;r<2;r++) {
	p1 = bridle.origin;	// начальная точка
	arr[r] = new Array();
	sum_x=0;sum_y=0;sum_z=0;num=0;
	// все полукрыло с 4 точками вдоль хорды для одного конца
	for (n=0;n<foils.length;n++) for(i=0;i<4/opt_8p;i++) {
		sum_x+=foils[n][bridle.points[r*4/opt_8p+i]].x;
		sum_y+=foils[n][bridle.points[r*4/opt_8p+i]].y;
		sum_z+=foils[n][bridle.points[r*4/opt_8p+i]].z;
		num++;
		}
	p = {x:sum_x/num, y:sum_y/num, z:sum_z/num};	// отрезок до средней точки
	len = pdist(p1,p);

	// укорачиваем отрезок до длины свободного конца по формуле: x = (x1+l*x2)/(1+l); где l = соотношение нижней к верхней длине подотрезков, например l=8:1
	l = opt_Bridle_Riser;	// cm
	l = l/(len-l);
	p.x = (p1.x+l*p.x)/(1+l);
	p.y = (p1.y+l*p.y)/(1+l);
	p.z = (p1.z+l*p.z)/(1+l);

	// запоминаем точку для тек. свободного конца
	arr[r].p = p;
	}



// нижний ярус по А и В на переднем конце
nlines = (opt_Bridle_Upper_Num*opt_Bridle_Middle_Num);
nup=opt_Bridle_Upper_Num;
nmid=opt_Bridle_Middle_Num;

for (r=0;r<2;r++) {
	p1 = arr[0].p;		// начальная точка - конец переднего конца

	arr[0][r]=new Array();
	// по стропам нижнего яруса
	for (n1=0;n1<(foils.length-opt_Tip_Line)/nlines;n1++) {
		arr[0][r][n1]=new Array();

		sum_x=0;sum_y=0;sum_z=0;num=0;
		// по 4 нервюры и по 2 точки вдоль размаха
		for (n=0;n<nlines;n++) if (n1*nlines+n<foils.length-opt_Tip_Line) for (i=0;i<2/opt_8p;i++) {
			sum_x+=foils[n1*nlines+n][bridle.points[r*2/opt_8p+i]].x;
			sum_y+=foils[n1*nlines+n][bridle.points[r*2/opt_8p+i]].y;
			sum_z+=foils[n1*nlines+n][bridle.points[r*2/opt_8p+i]].z;
			num++;
			}
		p = {x:sum_x/num, y:sum_y/num, z:sum_z/num};	// отрезок до средней точки
		len = pdist(p1,p);


		// укорачиваем отрезок до длины нижнего яруса например 60%
		l=len*(100-opt_Bridle_Middle)/100;
		l = l/(len-l);
		// можно расстояние задать вручную, в см
		//l=200;
		//l = (len-l)/l;
		p.x = (p1.x+l*p.x)/(1+l);
		p.y = (p1.y+l*p.y)/(1+l);
		p.z = (p1.z+l*p.z)/(1+l);

		// запоминаем точку для текущего ряда
		arr[0][r][n1].p = p;
		}
	}


// средне-верхний ярус А и В

for (r=0;r<2;r++) {
	// по стропам нижнего яруса
	for (n1=0;n1<arr[0][r].length;n1++) for (n2=0;n2<nmid;n2++) if (n1*nlines+n2*nup<foils.length-opt_Tip_Line) {
		arr[0][r][n1][n2]=new Array();

		p1 = arr[0][r][n1].p;			// начальная точка - конец нижнего яруса

		sum_x=0;sum_y=0;sum_z=0;num=0;
		// по количеству нервюр и по 2 точки вдоль хорды
		for (n=0;n<nup;n++) if (n1*nlines+n2*nup+n<foils.length-opt_Tip_Line) for (i=0;i<2/opt_8p;i++) {
			// точка на верхней поверхности
			fnum = n1*nlines+n2*nup+n;		// индекс нервюры
			pnum = r*2/opt_8p+i;					// индекс петельки
			p = foils[fnum][bridle.points[pnum]];

			// запомним ее как p (оригинальная точка на верхней поверхности), а также индекс нервюры, которой она принадлежит и индекс петельки
			arr[0][r][n1][n2][n*2/opt_8p+i] = {p:p, fnum:fnum, pnum:pnum, p2ind:bridle.points[pnum]};

			// суммируем для нахождения средней точки
			sum_x+=p.x;
			sum_y+=p.y;
			sum_z+=p.z;
			num++;
			}
		p = {x:sum_x/num, y:sum_y/num, z:sum_z/num};	// отрезок до средней точки
		len = pdist(p1,p);

		// укорачиваем отрезок до длины, чтобы на верхнем ярусе было например 20%
		l=len*(100-opt_Bridle_Upper)/100;
		l = l/(len-l);
		// можно расстояние задать вручную, в см
		//l=70;
		//l = (len-l)/l;
		p.x = (p1.x+l*p.x)/(1+l);
		p.y = (p1.y+l*p.y)/(1+l);
		p.z = (p1.z+l*p.z)/(1+l);

		// запоминаем точку для текущего ряда
		arr[0][r][n1][n2].p = p;

		// теперь, зная общую среднюю точку, припишем каждую стропу верхнего яруса своей нервюре
		for (n=0;n<arr[0][r][n1][n2].length;n++) {
			o = arr[0][r][n1][n2][n];				// объект
			bridle.ribs[o.fnum][o.pnum] = {p1:p, p2:o.p, p2ind:o.p2ind};		// начало и конец отрезка, p2ind - индекс точки на верхней поверхности
			}

		}
	}



// нижний ярус CD

	p1 = arr[1].p;		// начальная точка - конец заднего конца

	// по стропам нижнего яруса
	for (n1=0;n1<(foils.length-opt_Tip_Line)/nlines;n1++) {
		arr[1][n1]=new Array();

		sum_x=0;sum_y=0;sum_z=0;num=0;
		// по количеству нервюр и по 4 точки вдоль хорды
		for (n=0;n<nlines;n++) if (n1*nlines+n<foils.length-opt_Tip_Line) for (i=0;i<4/opt_8p;i++) {
			sum_x+=foils[n1*nlines+n][bridle.points[4/opt_8p+i]].x;
			sum_y+=foils[n1*nlines+n][bridle.points[4/opt_8p+i]].y;
			sum_z+=foils[n1*nlines+n][bridle.points[4/opt_8p+i]].z;
			num++;
			}
		p = {x:sum_x/num, y:sum_y/num, z:sum_z/num};	// отрезок до средней точки
		len = pdist(p1,p);

		// укорачиваем отрезок до длины нижнего яруса например 60%
		l=len*(100-opt_Bridle_Middle)/100;
		l = l/(len-l);
		// можно расстояние задать вручную, в см
		//l=200;
		//l = (len-l)/l;
		p.x = (p1.x+l*p.x)/(1+l);
		p.y = (p1.y+l*p.y)/(1+l);
		p.z = (p1.z+l*p.z)/(1+l);

		// запоминаем точку для текущего ряда
		arr[1][n1].p = p;
		}


// средне-верхний ярус CD
for (n1=0;n1<arr[1].length;n1++) for (r=0;r<2;r++) {	// по рядам C и D
	arr[1][n1][r] = new Array();

	p1 = arr[1][n1].p;	// начальная точка - конец нижнего ряда CD


	for (n2=0;n2<nmid;n2++)  if (n1*nlines+n2*nup<foils.length-opt_Tip_Line) {
		arr[1][n1][r][n2] = new Array();

		sum_x=0;sum_y=0;sum_z=0;num=0;
		// по количеству нервюр и по 2 точки вдоль хорды
		for (n=0;n<nup;n++) if (n1*nlines+n2*nup+n<foils.length-opt_Tip_Line) for (i=0;i<2/opt_8p;i++) {
			// точка на верхней поверхности
			fnum = n1*nlines+n2*nup+n;		// индекс нервюры
			pnum = 4/opt_8p+r*2/opt_8p+i;				// индекс петельки
			p = foils[fnum][bridle.points[pnum]];

			// запомним ее как p (оригинальная точка на верхней поверхности), а также индекс нервюры, которой она принадлежит и индекс петельки
			arr[1][n1][r][n2][n*2/opt_8p+i] = {p:p, fnum:fnum, pnum:pnum, p2ind:bridle.points[pnum]};

			// суммируем для нахождения средней точки
			sum_x+=p.x;
			sum_y+=p.y;
			sum_z+=p.z;
			num++;
			}
		p = {x:sum_x/num, y:sum_y/num, z:sum_z/num};	// отрезок до средней точки
		len = pdist(p1,p);

		// укорачиваем отрезок до длины, чтобы на верхнем ярусе было например 20%
		l=len*(100-opt_Bridle_Upper)/100;
		l = l/(len-l);
		// можно расстояние задать вручную, в см
		//l=70;
		//l = (len-l)/l;
		p.x = (p1.x+l*p.x)/(1+l);
		p.y = (p1.y+l*p.y)/(1+l);
		p.z = (p1.z+l*p.z)/(1+l);

		// запоминаем точку для текущего ряда
		arr[1][n1][r][n2].p = p;	// n1 и r меняются местами для CD по сравнению с А и B

		// теперь, зная общую среднюю точку, припишем каждую стропу верхнего яруса своей нервюре
		for (n=0;n<arr[1][n1][r][n2].length;n++) {
			o = arr[1][n1][r][n2][n];				// объект
			bridle.ribs[o.fnum][o.pnum] = {p1:p, p2:o.p, p2ind:o.p2ind};		// начало и конец отрезка, p2ind - индекс точки на верхней поверхности
			}
		}

	}




// -------------
// клеванты

// FIX: может стоит сделать еще один ярус, то есть свободный конец будет нижней стропой, остальные по аналогии с остальными

brake = new Array();
if (opt_Brake.length>2) brake=opt_Brake; else {
	for (i=opt_Brake[0];i<foils.length;i+=opt_Brake[1]) brake[brake.length]=i; 	// (from,step)
	}

// центральная стропа, все точки в brake

	p1 = arr.p0;	   // начальная точка (общая с кайтом)

	arr[2] = new Array();
	sum_x=0;sum_y=0;sum_z=0;num=0;
	// все полукрыло с точками на задней кромке, индексы которых перечислены в brake
	for (n=0;n<brake.length;n++) {
		sum_x+=foils[brake[n]][TE].x;
		sum_y+=foils[brake[n]][TE].y;
		sum_z+=foils[brake[n]][TE].z;
		num++;
		}
	p = {x:sum_x/num, y:sum_y/num, z:sum_z/num};	// отрезок до средней точки
	len = pdist(p1,p);

	// для кайта сначала уменьшим длину на длину основных строп, чтобы потом использовать % от высоты строповки
	if (opt_Kite_Lines) {
		p2 = {x:0, y:0, z:0};
		l2 = opt_Kite_Lines;	// cm
		l2 = l2/(len-l2);
		p2.x = (p1.x+l2*p.x)/(1+l2);
		p2.y = (p1.y+l2*p.y)/(1+l2);
		p2.z = (p1.z+l2*p.z)/(1+l2);
		// а теперь используем как начальную точку конец найденного укороченного отрезка
		p1 = p2;
		len = pdist(p1,p);
		}

	// запомним начальную (в случае удлинителей для кайта, "обрезанную") точку начала клевант для показа в 3D с отключенными удлинителями и для печати
	arr[2].p0 = p1;

	// укорачиваем отрезок до длина например 40%
	l=len*(100-opt_Brake_Middle)/100;
	l = l/(len-l);
	p.x = (p1.x+l*p.x)/(1+l);
	p.y = (p1.y+l*p.y)/(1+l);
	p.z = (p1.z+l*p.z)/(1+l);

	// запоминаем точку для клеванты
	arr[2].p = p;



// средне-верхний ярус клевант

	// по стропам нижнего яруса
	for (n1=0;n1<brake.length/opt_Brake_Upper_Num;n1++) {
		arr[2][n1]=new Array();

		p1 = arr[2].p;			// начальная точка - конец центральной клевантной стропы

		sum_x=0;sum_y=0;sum_z=0;num=0;
		// по opt_Brake_Upper_Num нервюры и по 1 точке на задней кромке
		for (n=0;n<opt_Brake_Upper_Num;n++) if (n1*opt_Brake_Upper_Num+n<brake.length) {
			// точка на верхней поверхности
			fnum = brake[n1*opt_Brake_Upper_Num+n];		// индекс нервюры
			pnum = 8/opt_8p;					// индекс петельки
			p = foils[fnum][TE];

			// запомним ее как p (оригинальная точка на верхней поверхности), а также индекс нервюры, которой она принадлежит и индекс петельки
			arr[2][n1][n] = {p:p, fnum:fnum, pnum:pnum};

			// суммируем для нахождения средней точки
			sum_x+=p.x;
			sum_y+=p.y;
			sum_z+=p.z;
			num++;
			}
		p = {x:sum_x/num, y:sum_y/num, z:sum_z/num};	// отрезок до средней точки
		len = pdist(p1,p);

		// укорачиваем отрезок до длины, чтобы на верхнем ярусе было например 20%
		l=len*(100-opt_Brake_Upper)/100;
		l = l/(len-l);
		p.x = (p1.x+l*p.x)/(1+l);
		p.y = (p1.y+l*p.y)/(1+l);
		p.z = (p1.z+l*p.z)/(1+l);

		// запоминаем точку для текущего ряда
		arr[2][n1].p = p;

		// теперь, зная общую среднюю точку, припишем каждую стропу верхнего яруса своей нервюре
		for (n=0;n<arr[2][n1].length;n++) {
			o = arr[2][n1][n];					// объект
			bridle.ribs[o.fnum][o.pnum] = {p1:p, p2:o.p, p:o.p};	// начало и конец отрезка, причем p указываем сразу, так как в клевантах она всегда лежит на верхней поверхности
			}
		}

// ----------------------------
// ушная стропа, если есть
//
if (opt_Tip_Line) {
	// начальная точка на переднем свободном конце
	p1 = arr[0].p;		// начальная точка - конец переднего конца

	arr[3]=new Array();

	// все 8 точек ушной секции в одну точку
	sum_x=0;sum_y=0;sum_z=0;num=0;
	// по 8 точкам неврюры
	for (i=0;i<8/opt_8p;i++) {
		sum_x+=foils[foils.length-1][bridle.points[i]].x;
		sum_y+=foils[foils.length-1][bridle.points[i]].y;
		sum_z+=foils[foils.length-1][bridle.points[i]].z;
		num++;
		}
	p = {x:sum_x/num, y:sum_y/num, z:sum_z/num};	// отрезок до средней точки
	len = pdist(p1,p);


	// укорачиваем отрезок до длины нижнего яруса например 60%
	l=len*(100-opt_Tip_Line_Height)/100;
	l = l/(len-l);
	// можно расстояние задать вручную, в см
	//l=200;
	//l = (len-l)/l;
	p.x = (p1.x+l*p.x)/(1+l);
	p.y = (p1.y+l*p.y)/(1+l);
	p.z = (p1.z+l*p.z)/(1+l);

	// запоминаем точку для текущего ряда
	arr[3].p = p;


	// по 8 стропам
	for (i=0;i<8/opt_8p;i++) {

		p1 = arr[3].p;			// начальная точка - конец нижнего яруса

		// точка на верхней поверхности
		p = foils[foils.length-1][bridle.points[i]];
		// запомним ее как p (оригинальная точка на верхней поверхности), а также индекс нервюры, которой она принадлежит и индекс петельки
		arr[3][i] = {p:p, fnum:(foils.length-1), pnum:i, p2ind:bridle.points[i]};


		// теперь, припишем каждую стропу верхнего яруса своей нервюре
		bridle.ribs[foils.length-1][i] = {p1:p1, p2:p, p2ind:bridle.points[i]};		// начало и конец отрезка, p2ind - индекс точки на верхней поверхности
		}

	}


bridle.arr=arr;


// а теперь пройдемся по всем нервюрам и сохраненным точкам верхнего яруса и укоротим их на длину треугольничков
// по всем нервюрам
for (n=0;n<bridle.ribs.length;n++) {
	// по всем петелькам, кроме последней для TE
	for (i=0;i<bridle.ribs[n].length-1;i++) {
		p1 = bridle.ribs[n][i].p1;		// начальная точка - общая точка схождения строп верхнего яруса
		p = bridle.ribs[n][i].p2;		// точка на верхней поверхности

		len = pdist(p1,p);

		// укоротим до длины треугольничка, кроме первых opt_Rib_Skip от носика нервюры
		if (i>=opt_Rib_Skip) {
			p = {x:p.x, y:p.y, z:p.z};		// делаем копию для p


			//l=len*(100-opt_Rib)/100;
			//l = l/(len-l);

			if (opt_Rib_Size!=0) {				// если 0, то нервюры сходятся в точку объединения строп вместо верхнего яруса
				if (opt_Rib_Camber==0) {		// высоты нервюр как % от хорды
					l = opt_Rib_Size*foils[n].chord/100;

					// линейное уменьшение высоты нервюр к хвосту согласно коэффициенту opt_Rib_Koeff (действует только при задании размера в % от хорды!)
					t = (i-opt_Rib_Skip)/(bridle.ribs[n].length-2-opt_Rib_Skip);	// 0..1
					t = (1-opt_Rib_Koeff)*t;
					t = 1-t;
					l = l*t;

					} else {			// высота нервюр как % от толщины профиля. треугольники повторяют форму профиля
						tmp_h = foil.camber*foil.chord/100;	// высота профиля
						tmp_k = (foil[bridle.points[i]].y+foil.dy)/tmp_h;			// коэфф. отношения высоты тек. точки к высоте профиля
						l = opt_Rib_Camber*(foils[n].camber*foils[n].chord*tmp_k/100)/100;	// от толщины профиля
						}

				l = (len-l)/l;

				p.x = (p1.x+l*p.x)/(1+l);
				p.y = (p1.y+l*p.y)/(1+l);
				p.z = (p1.z+l*p.z)/(1+l);
				} else if (!(n==bridle.ribs.length-1 && opt_Tip_Line==1)) p = {x:p1.x, y:p1.y, z:p1.z};		// делаем копию (кроме ушной стропы)

			bridle.ribs[n][i].p=p;			// запоминаем как реальную точку окончания вехнего яруса p
			} else {
				// для неукорачиваемых точка p лежит на верхней поверхности
				bridle.ribs[n][i].p = bridle.ribs[n][i].p2;
				}
		}
	}


// --------------------------------------------------------------
// ТРЕХМЕРНАЯ МОДЕЛЬ
// --------------------------------------------------------------

// ВНИМАНИЕ! При открытии DXF в Google SketchUp нужно указать масштаб (по умолчанию миллиметры) и поставить галку Preserve drawing origin, чтобы SketchUp не переносил сам ограничивающий объем в начало координат

fso = WScript.CreateObject("Scripting.FileSystemObject");
f = fso.OpenTextFile("wing_3d.dxf",2,true);		// с перезаписью файлов
f.WriteLine("0\r\nSECTION\r\n2\r\nENTITIES");			//начальная часть файла (обязательно)

// по всем секциям
if (opt_Show_Wing || opt_Show_Nervures) for(ind=0;ind<foils.length;ind++) {
	p=foils[ind];
	f.WriteLine("0\r\nPOLYLINE");		// POLYLINE, потом 38 - высота z, потом 10,20,10,20
	f.WriteLine("70\r\n8");			// флаг, что это 3D Polyline
	f.WriteLine("8\r\n0");			// обязательно для полилиний поле с названием слоя 0
	f.WriteLine("66\r\n1");			// обязательно поле для полилиний
	for (i=0;i<p.length;i++) {		// далее для каждой точки свой VERTEX
		f.WriteLine("0\r\nVERTEX");
		f.WriteLine("8\r\n0");			// обязательно название слоя 0
		f.WriteLine("10\r\n"+p[i].x*print_scale);	// x
		f.WriteLine("20\r\n"+p[i].y*print_scale);	// y
		f.WriteLine("30\r\n"+p[i].z*print_scale);	// z
		}
	f.WriteLine("0\r\nSEQEND");		// конец последовательности вертексов в POLYLINE

	// рисуем вертикальные черточки на AR где должны быть нервюры
	// line3d(foils[ind].x,0,foils[ind].z,foils[ind].x,0,(foils[ind].z+10));
	// рисуем хорды на плоскости XY
	//line3d(foils[ind].x,foils[ind].y,0,foils[ind].x,(foils[ind].y-foils[ind].chord),0);


	// рисуем линию LE
	if (ind==0) p1={x:0, y:foils[ind][LE].y, z:foils[ind][LE].z}; else p1={x:foils[ind-1][LE].x, y:foils[ind-1][LE].y, z:foils[ind-1][LE].z};
	p2 = foils[ind][LE];
	pline3d(p1,p2);
	if (opt_Draw_Half==0) pline3dr(p1,p2);
	// рисуем линию TE
	if (ind==0) p1={x:0, y:foils[ind][TE].y, z:foils[ind][TE].z}; else p1={x:foils[ind-1][TE].x, y:foils[ind-1][TE].y, z:foils[ind-1][TE].z};
	p2 = foils[ind][TE];
	pline3d(p1,p2);
	if (opt_Draw_Half==0) pline3dr(p1,p2);
	// рисуем линию VENT
	if (ind==0) p1={x:0, y:foils[ind][VENT].y, z:foils[ind][VENT].z}; else p1={x:foils[ind-1][VENT].x, y:foils[ind-1][VENT].y, z:foils[ind-1][VENT].z};
	p2 = foils[ind][VENT];
	pline3d(p1,p2);
	if (opt_Draw_Half==0) pline3dr(p1,p2);

	}//for



// рисуем строповку	// arr[передний конец][A|B][размах][средний ярус][верхний ярус].p,p1, arr[задний конец][размах][A|B][средний ярус][верхний ярус].p,p1, arr[клеванты][нижний ярус][средний ярус][верхний ярус].p


// свободные концы
if (opt_Show_AB || opt_Show_CD) {
pline3d(bridle.origin, arr[0].p);
pline3d(bridle.origin, arr[1].p);
if (opt_Draw_Half==0) {
	pline3dr(bridle.origin, arr[0].p);
	pline3dr(bridle.origin, arr[1].p);
	}
}//show_AB || CD

if (opt_Kite_Lines && opt_Show_Kite_Lines) {
	// рисуем кайтовые основные стропы
	pline3d(arr.p0,bridle.origin);
	if (opt_Draw_Half==0) pline3dr(arr.p0,bridle.origin);
	}

lenup=0;lenmid=0;lenlow=0;lenklow=0;lenkup=0;
lennum=0;


// по переднему концу A и В
if (opt_Show_AB) {
for (i=0;i<arr[0].length;i++) for (j=0;j<arr[0][i].length;j++) {
	// нижний ярус
	pline3d(arr[0].p, arr[0][i][j].p);
	if (opt_Draw_Half==0) pline3dr(arr[0].p, arr[0][i][j].p);
	lenlow+=pdist(arr[0].p, arr[0][i][j].p); lennum+=1;

	// по средне-верхнему ярусу
	for(k=0;k<arr[0][i][j].length;k++) {
		pline3d(arr[0][i][j].p,arr[0][i][j][k].p);
		if (opt_Draw_Half==0) pline3dr(arr[0][i][j].p,arr[0][i][j][k].p);
		lenmid+=pdist(arr[0][i][j].p,arr[0][i][j][k].p); lennum+=1;
		}
	}
// отдельно выведем ушную стропу
if (opt_Tip_Line) {
	pline3d(arr[0].p,arr[3].p);
	if (opt_Draw_Half==0) pline3dr(arr[0].p,arr[3].p);
	lenmid+=pdist(arr[0].p,arr[3].p); lennum+=1;	// длину ушной стропы припишем ко второму ярусу, так как она обычно тоньше, чем нижний ярус
	}
}// show-AB


// по заднему концу CD
if (opt_Show_CD) {
for (i=0;i<arr[1].length;i++) {
	// нижний уровень
	pline3d(arr[1].p, arr[1][i].p);
	if (opt_Draw_Half==0) pline3dr(arr[1].p, arr[1][i].p);
	lenlow+=pdist(arr[1].p, arr[1][i].p); lennum+=1;

	// С и D
	for (j=0;j<arr[1][i].length;j++) for (k=0;k<arr[1][i][j].length;k++) {
		// средний ярус
		pline3d(arr[1][i].p, arr[1][i][j][k].p);
		if (opt_Draw_Half==0) pline3dr(arr[1][i].p, arr[1][i][j][k].p);
		lenmid+=pdist(arr[1][i].p, arr[1][i][j][k].p);  lennum+=1;
		}
	}
}//show_CD

// ------------------
// клеванты


// центральная стропа
if (opt_Show_Brakes) {
	// "обрезанная" длина клевант, если не нужно показывать основые 30 м стропы кайта
	pline3d(arr[2].p0,arr[2].p);
	if (opt_Draw_Half==0) pline3dr(arr[2].p0,arr[2].p);

	// если нужно, покажем удлинители
	if (opt_Kite_Lines && opt_Show_Kite_Lines) {
		pline3d(arr.p0,arr[2].p);
		if (opt_Draw_Half==0) pline3dr(arr.p0,arr[2].p);
		}
lenklow+=pdist(arr.p0,arr[2].p);

// по среднему ярусу
for (i=0;i<arr[2].length;i++) {
	// средний ярус
	pline3d(arr[2].p, arr[2][i].p);
	if (opt_Draw_Half==0) pline3dr(arr[2].p, arr[2][i].p);
	lenkup+=pdist(arr[2].p, arr[2][i].p);
	}
}//show_Brakes



// -----------------
// верхний ярус выводим отдельно из-за укороченных строп на длину треугольничков


// по всем нервюрам
for (n=0;n<bridle.ribs.length;n++) {
	// по всем петелькам
	for (i=0;i<bridle.ribs[n].length;i++) if (bridle.ribs[n][i]!=null) 				// если null, то на этой нервюре нет клевантной стропы
		if (opt_Show_AB && i<4 || opt_Show_CD && i>3 && i<8 || opt_Show_Brakes && i==8) {
		pline3d(bridle.ribs[n][i].p1, bridle.ribs[n][i].p);
		lenup+=pdist(bridle.ribs[n][i].p1, bridle.ribs[n][i].p);
		lennum+=1; //FIX: клеванты считать отдельно

		if (opt_Draw_Half==0) pline3dr(bridle.ribs[n][i].p1, bridle.ribs[n][i].p);
		}
	}


// -----------------
// нервюры


if (opt_Show_Nervures) {
// по всем нервюрам
for (n=0;n<bridle.ribs.length;n++) {
	ple = null;
	// по всем петелькам, начиная с носика
	for(i=0;i<8/opt_8p;i++) {
		// рисуем квадратичную кривую безье между кончиками треугольников
		// первая петелька
		p1 = bridle.ribs[n][i].p;
		// вторая  контрольная точка, середина точка между петельками на верхней поверхности, для последней точка продолжения строповки для более изогнутого треугольника
		if (i<(8/opt_8p)-1) p2 = foils[n][bridle.mpoints[i]]; else {
			if (opt_8p==1) p2 = foils[n][bridle.ribs[n][i].p2ind]; else p2 = foils[n][bridle.mpoints[i]]; // для 4 точек менее изогнутый треугольник
			}
		// вторая петелька (от последней петельки кривая идет к TE)
		if (i<(8/opt_8p)-1) p3 = bridle.ribs[n][i+1].p; else p3=foils[n][TE];

		if (i<(8/opt_8p)-1) {
			// увеличим длину средней точки почти в два раза, иначе арочность треугольников маленькая
			// находим середину отрезка между петельками
			x = (p1.x+p3.x)/2;
			y = (p1.y+p3.y)/2;
			z = (p1.z+p3.z)/2;

			// переносим в начало координат
			x1 = p2.x-x;
			y1 = p2.y-y;
			z1 = p2.z-z;

			// удлиняем на 180% и смещаем обратно
			x1 = x1*opt_Rib_Scale + x;
			y1 = y1*opt_Rib_Scale + y;
			z1 = z1*opt_Rib_Scale + z;

			// рисуем безье
			b = new Array(p1.x,p1.y,p1.z, x1,y1,z1, p3.x,p3.y,p3.z);
			} else {
				// для задней кромки не используем масштабирование, иначе линия уходит выше верхней поверхности
				b = new Array(p1.x,p1.y,p1.z, p2.x,p2.y,p2.z, p3.x,p3.y,p3.z);
				}

		// запомним точку середины первого безье для носика
		if (i==0) {
			ple = {x:bezier(b,0.5,"x"), y:bezier(b,0.5,"y"), z:bezier(b,0.5,"z")};
			}


		// рисуем безье
		if (opt_Rib_Straight==0) {
			ar = draw_bezier(b,1);
			draw_polyline(ar);
			if (opt_Show_Rib_Polygons) draw_btri(ar,n);

			if (opt_Draw_Half==0) {
				b[0]=-b[0];
				b[3]=-b[3];
				b[6]=-b[6];
				ar = draw_bezier(b,1);
				draw_polyline(ar);
				if (opt_Show_Rib_Polygons) draw_btri(ar,n, 1);	//inv
				}
			} else {
				// иначе рисуем треугольники с прямыми линиями
				draw_straight(b,p1,p3,n);
				}

		}//по всем петелькам


	// дорисуем прямую линию от носика до первой середины отрезка, если первая петелька меньше длины профиля (лежит на носике)
	if (bridle.points[0]<VENT) {
		pline3d(foils[n][VENT],ple);
		if (opt_Draw_Half==0) pline3dr(foils[n][VENT],ple);
		}

	// дорисуем прямую линию от А до A0
	pline3d(foils[n][bridle.points[0]],foils[n][A0]);
	if (opt_Draw_Half==0) pline3dr(foils[n][bridle.points[0]],foils[n][A0]);

	}
}//show_nervures



// -----------------
// нарисуем САХ

if (opt_Show_CAX) line3d(foils.CAX.x1,foils.CAX.y1,0,foils.CAX.x2,foils.CAX.y2,0);



//--------------------------------------------
// второе полукрыло, по всем секциям


if (opt_Show_Wing || opt_Show_Nervures) if (opt_Draw_Half==0) {
for(ind=0;ind<foils.length;ind++) {
	p=foils[ind];
	f.WriteLine("0\r\nPOLYLINE");		// POLYLINE, потом 38 - высота z, потом 10,20,10,20
	f.WriteLine("70\r\n8");			// флаг, что это 3D Polyline
	f.WriteLine("8\r\n0");			// обязательно для полилиний поле с названием слоя 0
	f.WriteLine("66\r\n1");			// обязательно поле для полилиний
	for (i=0;i<p.length;i++) {		// далее для каждой точки свой VERTEX
		f.WriteLine("0\r\nVERTEX");
		f.WriteLine("8\r\n0");		// слой 0
		f.WriteLine("10\r\n"+(-p[i].x)*print_scale);// x
		f.WriteLine("20\r\n"+p[i].y*print_scale);	// y
		f.WriteLine("30\r\n"+p[i].z*print_scale);	// z
		}
	f.WriteLine("0\r\nSEQEND");		// конец последовательности вертексов в POLYLINE
	}//for
}//draw_half




// --------------------------------------------------------------
// ПОСТРОЕНИЕ ПЛОСКИХ НЕРВЮР
// --------------------------------------------------------------

// расчет плоских нервюр

// рассчитаем плоские треугольники
// по всем нервюрам
for (n=0;n<bridle.ribs.length;n++) {
	ribs[n].tri = new Array();
	// по всем петелькам, начиная с носика
	for(i=0;i<8/opt_8p;i++) {
		if (i<opt_Rib_Skip) {
		// для неукорачиваемых нервюр плоская точка лежит на поверхности лобика
		ribs[n].tri[i] = {p:ribs[n][bridle.ribs[n][i].p2ind]};

		} else {
		// иначе определим угол между стропой верхнего яруса и нервюрой и повернем длину отрезка на такой же угол
		p = bridle.ribs[n][i].p;				// точка в вершине треугольника
		p2 = bridle.ribs[n][i].p2;				// точка на верхней поверхности как продолжение строповки
		//if (bridle.points[i]>0) p3 = foils[n][bridle.points[i]-1]; else p3=foils[n][TE];		// точка отрезка на профиле ближе к хвостику
		if (bridle.ribs[n][i].p2ind>0) p3 = foils[n][bridle.ribs[n][i].p2ind-1]; else p3=foils[n][TE];		// точка отрезка на профиле ближе к хвостику
		//p3=foils[n][TE];		  // FIX: углы получаются разные, так как это уже не плоский треугольник
/*
circle3d(p);
circle3d(p2);
circle3d(p3);
*/
		len = pdist(p,p2);		// расстояние от точки схождения строп верхнего яруса до точки на поверхности

		// переносим вектор с трехмерной нервюры в начало координат
		pt = {x:p.x-p2.x,y:p.y-p2.y,z:p.z-p2.z};
		a = Math.acos(pt.x/len)*180.0/Math.PI;	// угол относительно горизонта
		a=270+a;								// доворачиваем до вертикального состояния
		a=a*Math.PI/180.0;						// переводим в радианы

		// повернем относительно Y, то есть по арочности
		x=pt.x; y=pt.z;
		pt.x = x * Math.cos(a) - y * Math.sin(a);
		pt.z = x * Math.sin(a) + y * Math.cos(a);

		// смещаем в точку на верхн. поверхности для плоского профиля
		p2 = ribs[n][bridle.ribs[n][i].p2ind];	 	 										// точка на верхней поверхности плоской нервюры
		pt.x=pt.x+p2.x;
		pt.y=pt.y+p2.y;
		pt.z=pt.z+p2.z;

		// запоминаем положение вершины треугольника в плоской нервюре
		ribs[n].tri[i] = {p:pt};
		}//< Rib_Skip
		}
	}



// теперь создадим массивы с полилиниями для каждой нервюры  ribs[n].lines[контур,шов контура,8петелек[точка,точка,безье,шов],прямая от носика до середины,шов,прямая А-А0,точка,леска]
for (n=0;n<bridle.ribs.length;n++) {
	ribs[n].lines = new Array();
	ribs[n].len = 0;				// длина вшитого шнура

	sewarr = new Array();			// массив точек начала и конца шва для каждой петельки (нужно для последующего их соединения для непрерывности)
	sewnum = 0;	   					// индекс для запоминания пред. шва для устранения артефактов на пересечениях отрезков

	// добавляем в массив полилиний контур нервюры
	ribs[n].lines[0] = ribs[n];		// FIX: возможно, лучше копировать все точки по отдельности
	// добавляем отступ на шов
	ribs[n].lines[1] = add_sew(ribs[n],print_sew,0,0,print_TE,print_sew_rib);	// с удлинением начала и конца на ширину швов

	ple = null;
	// по всем петелькам, начиная с носика
	for(i=0;i<8/opt_8p;i++) {

		// рисуем квадратичную кривую безье между кончиками треугольников
		// начальная контрольная точка, первая петелька (вершина первого плоского треугольника)
		p1 = ribs[n].tri[i].p;
		// вторая  контрольная точка, средняя точка между петельками на верхней поверхности плоского профиля, для последней точка продолжения строповки для более изогнутого треугольника
		if (i<(8/opt_8p)-1) p2 = ribs[n][bridle.mpoints[i]]; else {
			if (opt_8p==1) p2 = ribs[n][bridle.ribs[n][i].p2ind]; else p2 = ribs[n][bridle.mpoints[i]]; // для 4 точек менее изогнутый треугольник
			}
		// третья контрольная точка вторая петелька, для последней точка TE
		if (i<(8/opt_8p)-1) p3 = ribs[n].tri[i+1].p; else p3=ribs[n][TE];

		/*
		// проверки, при печати отключить
		circle3d(p1);  	 // первая петелька
		//circle3d(p2);	 // середина между петельками
		circle3d(p3);	 // вторая петелька
		circle3d(ribs[n][bridle.ribs[n][i].p2ind]);		// точка на верхней поверхности как продолжение строповки
		circle3d(ribs[n][bridle.ribs[n][i].p2ind-1]);	// соседняя точка к хвостику
		*/

		// нарисуем точки на профиле
		ribs[n].lines[ribs[n].lines.length] = circle3d(p1,1); 		// текущая петелька
		// реперные точки
		if (print_reper==0) {
			if (opt_8p!=1) ribs[n].lines[ribs[n].lines.length] = circle3d(p2,1); 		// средняя точка между петелькаями, только для 4 треуг., иначе слишком частые точки
			ribs[n].lines[ribs[n].lines.length] = circle3d(ribs[n][bridle.ribs[n][i].p2ind],1); 	// точка продолжения строповки на верхней поверхности
			}

		if (i<(8/opt_8p)-1) {
			// увеличим длину от средней точки на верхней поверхности до середины отрезка, соединяющего петельки, почти в два раза, иначе при чистой параболе арочность треугольников маленькая
			// находим середину отрезка между петельками
			x = (p1.x+p3.x)/2;
			y = (p1.y+p3.y)/2;
			z = (p1.z+p3.z)/2;

			// проверка правильности построения средней линии, при печати выключить
			//ribs[n].lines[ribs[n].lines.length] = circle3d(p2,1); 		// средняя точка между петелькаями
			//ribs[n].lines[ribs[n].lines.length] = circle3d({x:x,y:y,z:z},1);

			// переносим в начало координат
			x1 = p2.x-x;
			y1 = p2.y-y;
			z1 = p2.z-z;

			// удлиняем на 180% и смещаем обратно
			x1 = x1*opt_Rib_Scale + x;
			y1 = y1*opt_Rib_Scale + y;
			z1 = z1*opt_Rib_Scale + z;

			// проверка правильности построения средней линии, при печати выключить
			//ribs[n].lines[ribs[n].lines.length] = circle3d({x:x1,y:y1,z:z1},1);

			// создаем безье
			b = new Array(p1.x,p1.y,p1.z, x1,y1,z1, p3.x,p3.y,p3.z);
			} else b = new Array(p1.x,p1.y,p1.z, p2.x,p2.y,p2.z, p3.x,p3.y,p3.z);  // для задней кромки не используем масштабирование, иначе линия уходит выше верхней поверхности

		// рисуем безье
		if (opt_Rib_Straight==0) {
			ar = draw_bezier(b,1); 	// возвращает массив точек
			} else {
				// иначе для треугольников с прямыми линиями сами создадим массив точек из двух прямых линий
				// средняя точка оригинальной кривой безье
				tp = {x:bezier(b,0.5,"x"), y:bezier(b,0.5,"y"), z:bezier(b,0.5,"z")};
				ar=new Array();
				ar.add(p1.x,p1.y,p1.z);		// начальная точка
				ar.add(tp.x,tp.y,tp.z);		// средняя точка
				ar.add(p3.x,p3.y,p3.z);		// конечная точка
				}

		ribs[n].lines[ribs[n].lines.length] = ar;
		// добавляем отступ на шов
		ribs[n].lines[ribs[n].lines.length] = add_sew(ar,print_sew_rib, false, (i==0 && bridle.points[0]<VENT),print_sew_rib,(i<(8/opt_8p-1)?print_sew_rib:print_TE));	// для первой петельки делаем шов только во второй половине кривой, причем только если она лежит не на краю носика нервюры

		// проверим пересечение с окончанием предыдущего шва и устраним уголки-артефакты, если они есть
		if (i>0) {
			t1 = ribs[n].lines[ribs[n].lines.length-1][0];	// первый отрезок: первая и вторая точка последней полилинии
			t2 = ribs[n].lines[ribs[n].lines.length-1][1];

			tmplen=ribs[n].lines[sewnum].length-1;
			t3 = ribs[n].lines[sewnum][tmplen];		// второй отрезок: последняя и предпоследняя точка предыдущей полилинии
			t4 = ribs[n].lines[sewnum][tmplen-1];
			res = intersect(t1.y,t1.z, t2.y,t2.z, t3.y,t3.z, t4.y,t4.z);	// внимание! вместо х,у, реальные координаты y,z
			if (res[0]!=0 && res[1]!=0) {
				// есть пересечение отрезков! удалим артефакт, заменив две точки на одну (точнее, задав их координаты как координаты пересечения, т.е. длина соедининяющего их отрезка станет равна нулю )
				ribs[n].lines[ribs[n].lines.length-1][0] = {x:0,y:res[0],z:res[1]};
				ribs[n].lines[sewnum][tmplen] = {x:0,y:res[0],z:res[1]};
				sewarr[i-1].p2 = {x:0,y:res[0],z:res[1]};	// подправим также запомненную точку конца пред. шва
				}
			}
		// запомним индекс шва в массиве полилиний
		sewnum = ribs[n].lines.length-1;

		// для каждой петельки запоминаем точки начала и конца шва, чтобы потом соединить их для непрерываности
		tt=ribs[n].lines[ribs[n].lines.length-1];
		sewarr[i] = {p1:tt[0], p2:tt[tt.length-1]};


		// суммируем длины безье для вшитого шнура между строповкой (по нечетным индексам  0,1-2,3-4,5-6,7-8)
		if (((i/2)+"").indexOf(".")!=-1) ribs[n].len=ribs[n].len+len_polyline(ribs[n].lines[ribs[n].lines.length-2]);

		// запомним точку середины первого безье для носика
		if (i==0) {
			ple = {x:bezier(b,0.5,"x"), y:bezier(b,0.5,"y"), z:bezier(b,0.5,"z")};
			}
		}//for i<8


	// добавим дополнительные реперные точки
	if (print_reper==0) {
		// добавим две реперных точек на лобике, а то мало по умолчанию
		ribs[n].lines[ribs[n].lines.length] = circle3d(ribs[n][REPER1],1);
		ribs[n].lines[ribs[n].lines.length] = circle3d(ribs[n][REPER2],1);
		} else {	// реперные точки как % от общего числа точек в профиле
			step=Math.round((foil.length-1)/(print_reper*(foil.length-1)/100));
			for (i=step;i<foil.length-1;i+=step) ribs[n].lines[ribs[n].lines.length] = circle3d(ribs[n][i],1);
			}

	// дорисуем прямую линию от носика до первой середины отрезка, если первая петелька не лежит на краю носика нервюры
	if (bridle.points[0]<VENT) {
		p=ribs[n][VENT];
		//line3d(p.x,p.y,p.z, ple.x,ple.y,ple.z);
		ar =  new Array();
		ar.add(p);
		ar.add(ple);
		ribs[n].lines[ribs[n].lines.length] = ar;
		// добавляем отступ на шов
		ribs[n].lines[ribs[n].lines.length] = add_sew(ar,print_sew_rib,0,0,print_sew,0);	// конечную не надо удлинять
		}
	// дорисуем прямую линию от А до A0
	p=ribs[n][bridle.points[0]];
	ple=ribs[n][A0];
	//line3d(p.x,p.y,p.z, ple.x,ple.y,ple.z);
	ar =  new Array();
	ar.add(p);
	ar.add(ple);
	ribs[n].lines[ribs[n].lines.length] = ar; // отступ для шва добавлять не надо, т.к. это одна линия
	// добавим эту линию к длине вшитого шнура
	ribs[n].len+=len_polyline(ribs[n].lines[ribs[n].lines.length-1]);
	// и добавим точку в А0 для синхронизации, так как на полотнищах здесь точки
	ribs[n].lines[ribs[n].lines.length] = circle3d(ple,1);

	// дорисуем перпендикулярну линию на шве где начинается леска, высота линии равна ширине шва
	p=ribs[n][L0];
	ple=ribs[n][L0+1];	// след. точка в отрезке, нужна для расчет перпендикуляра к нему
	ple=rotate_sew(p,ple,print_sew);
	//line3d(p.x,p.y,p.z, ple.x,ple.y,ple.z);
	ar =  new Array();
	ar.add(p);
	ar.add(ple);
	ribs[n].lines[ribs[n].lines.length] = ar;

	// соединим концы полилиний швов
	// по всем петелькам, кроме первой. до 9, так как последнее дополнительное соединение с задней кромкой
	for (i=1;i<(8/opt_8p+1);i++){
		// на последнем соединении соединяем с задней кромкой, иначе с окончанием шва предыдущей петельки
		if (i==8/opt_8p) p=ribs[n].lines[1][0]; else p=sewarr[i-1].p2;
		// у последнего соединения конец последней петельки, иначе начало текущей
		if (i==8/opt_8p) ple=sewarr[(8/opt_8p-1)].p2;	else ple=sewarr[i].p1;
		// соединяем две точки, только если их координаты не совпадают
		if (p.x!=ple.x || p.y!=ple.y || p.z!=ple.z) {
			ar =  new Array();
			ar.add(p);
			ar.add(ple);
			ribs[n].lines[ribs[n].lines.length] = ar;
			}
		}

	// FIX: тут можно добавить леску на задней кромке
	}

	// рисуем все полилинии...
	if (opt_Show_Ribs) {
		dz=0;
		for (n=0;n<ribs.length;n++) {
			for (i=0;i<ribs[n].lines.length;i++) draw_polyline(ribs[n].lines[i],0,0,dz);
			dz+=40; //cm
			}
		}//if opt_Show_Ribs





// --------------------------------------------------------------
// ПОСТРОЕНИЕ ПЛОСКИХ ПАНЕЛЕЙ
// --------------------------------------------------------------


// для каждой панели две кривых: левая и правая (при виде снизу)
panels = new Array();	 // panels[нервюры][L,R,LO,RO,LE,TE,LS,LR][точки]	L - левая, R - правая, LO - матрасность (овализация), LS - линия отступа шва
dz=0;


// по всем нервюрам
for (n=0;n<foils.length;n++) {
	panels[n] = new Array();
	panels[n][0] = new Array();		// L кривая панели
	panels[n][1] = new Array();		// R кривая панели

//WScript.echo(panels.length);
//WScript.quit();
	x0=0; y0=0;	  	  	// смещение тек. четырехугольника
	theta=0;	  	  	// угол поворота тек. четырехугольника

	// по всем точкам
	for (i=0;i<foils[n].length-1;i++) {		// -1 т.к. работаем с отрезками
		// определяем 4 точки L1,L2,R1,R2 при виде снизу. идем по нервюрам от центроплана к ушам и по точкам от хвостика к передней кромке
		if (n==0) {
			// для первой нервюры левая сторона является оражением нервюры
			R1 = foils[n][i];
			R2 = foils[n][i+1];
			L1 = {x:-R1.x, y:R1.y, z:R1.z};
			L2 = {x:-R2.x, y:R2.y, z:R2.z};

			} else {
				// для остальных это просто точки от соседних нервюр
				L1 = foils[n-1][i];
				L2 = foils[n-1][i+1];
				R1 = foils[n][i];
				R2 = foils[n][i+1];
				}

		// расстояния между всеми комбинациями точек
		a = pdist(L1,R1);
		b = pdist(L1,R2);
		c = pdist(R1,R2);
		d = pdist(R1,L2);
		e = pdist(L1,L2);
		//f = pdist(L2,R2);

		// вспомогательные переменные
		a2L = ( a*a -e*e + d*d ) / ( 2*a );
		a1L = a - a2L;
		hL = Math.sqrt( d*d - a2L*a2L );

		a2R = ( a*a -b*b + c*c ) / ( 2*a );
		a1R = a - a2R;
		hR = Math.sqrt ( c*c - a2R*a2R );

		// координаты плоского четырехугольника на плоскости, перезаписываем трехмерные координаты, т.к. они нам больше не нужны (все что нужно рассчитано выше для длин отрезков)
		// координаты для справки, ниже перепишутся по полнным формулам
		L1 = {x:0, y:0, z:0};
		L2 = {x:a1L, y:hL, z:0};
		R1 = {x:a, y:0, z:0};
		R2 = {x:a1R, y:hR, z:0};


		// теперь повернем четырехугольника на угол и сместим в тек. координаты
	    L1.x=x0;
	    L1.y=y0;

	    R1.x=a*Math.cos(theta)+x0;
	    R1.y=a*Math.sin(theta)+y0;

	    L2.x=a1L*Math.cos(theta)-hL*Math.sin(theta)+x0;
	    L2.y=a1L*Math.sin(theta)+hL*Math.cos(theta)+y0;

	    R2.x=a1R*Math.cos(theta)-hR*Math.sin(theta)+x0;
	    R2.y=a1R*Math.sin(theta)+hR*Math.cos(theta)+y0;

	    x0=L2.x;
	    y0=L2.y;
	    theta=Math.atan((R2.y-L2.y)/(R2.x-L2.x));	// угол L2-R2 относительно оси Х
	    if (theta>0) theta=-theta;			// защита от глюков при чрезмерных углах

		// поменяем координаты местами, чтобы отступ для шва правильно считался
		L1.z = L1.x;
		L1.x=0;
		R1.z = R1.x;
		R1.x=0;
		L2.z = L2.x;
		L2.x=0;
		R2.z = R2.x;
		R2.x=0;


		// сохраним в массиве
		panels[n][0][i] = L1;
		panels[n][0][i+1] = L2;			// i+1 точки каждый раз перезаписываются, но это не страшно, т.к. в последнем четырехугольнике сохранятся последние точки LE
		panels[n][1][i] = R1;
		panels[n][1][i+1] = R2;
		}//for all points




	//-------------------------------
	// МАТРАСНОСТЬ

	panels[n][2] = new Array();		// L oval
	panels[n][3] = new Array();		// R oval

	// по всем точкам левой и правой кривой, кроме первой и последней т.к. они совпадают с LE и TE
	for (r=0;r<2;r++) for (i=1;i<panels[n][r].length-1;i++) {
		// текущая ширина панели
		w = pdist(panels[n][0][i],panels[n][1][i]);
		// прибавка к ширине (половина процентов, так как идем с одной стороны)
		w = w*(print_oval.val/2)/100;

		// отрезок для поворота
		p1 = panels[n][r][i];
		p2 = panels[n][r][i+1];

		if (i<=OT) {
			// интерполяция от задней кромки
			k = (foil[TE].x-foil[i].x)/(foil[TE].x-foil[OT].x);	// коэфф. расстояния по хорде до хвостика
			w=w*k; 			   		  							// ширину делаем пропорционально расстоянию
			} else if (i>=OL) {
				// интерполяция от передней кромки. ВНИМАНИЕ! от OL панель сужается до LE, а потом опять расширяется до VENT, так и должно быть! так как отсчет процентов по хорде, а нижняя часть лобика как бы является частью нижней поверхности и поэтому тоже раздувается начиная с 10% хорды
				k = (foil[i].x-foil[LE].x)/(foil[OL].x-foil[LE].x);	// коэфф. расстояния по хорде до носика
				w=w*k; 			   		  							// ширину делаем пропорционально расстоянию
				}

		// находим точку отступа на ширину
		p = rotate_sew(p1,p2,w,(r==1));		// для R инвертируем

		// сохраняем точку
		panels[n][2+r][i]={x:p.x, y:p.y, z:p.z};

		// первую и последнюю точку добавим принудительно
		if (i==1) panels[n][2+r][0]=panels[n][r][0];
		if (i==panels[n][r].length-2) panels[n][2+r][i+1]=panels[n][r][i+1];
		}
	// ------------------------------


	// добавим линии для передней и задней кромки
	panels[n][panels[n].length] = new Array(panels[n][1][0],panels[n][0][0]);	// TE точки в обратном порядке, чтобы шов рисовался с правильной стороны
	panels[n][panels[n].length] = new Array(panels[n][0][panels[n][0].length-1],panels[n][1][panels[n][1].length-1]); // LE

	// добавим отступы на шов вдоль панелей
	panels[n][panels[n].length] = add_sew(panels[n][2],print_sew,0,0,print_TE,print_LE);		// L, с удлинением начала и конца линии на ширину соседнего шва
	panels[n][panels[n].length] = add_sew(panels[n][3],print_sew,true,0,print_TE,print_LE);		// R, инвертируем направление отступа
	// отступы шов на передней и задней кромке
	panels[n][panels[n].length] = add_sew(panels[n][4],print_TE,0,0,print_sew,print_sew);		// TE, с удлинением начала и конца на ширину шва
	panels[n][panels[n].length] = add_sew(panels[n][5],print_LE,0,0,print_sew,print_sew);		// LE


	// добавим реперные точки, аналогичные как были на нервюрах
	// по всем петелькам, начиная с носика
	if (print_reper==0) {
		for (r=2;r<4;r++) {		// на линии овализации LO, RO
			for(i=0;i<8/opt_8p;i++) {
				if (opt_8p!=1) panels[n][panels[n].length] = circle3d(panels[n][r][bridle.mpoints[i]],1); 		// средняя точка между петельками, только для 4 треуг., иначе слишком часто
				panels[n][panels[n].length] = circle3d(panels[n][r][bridle.ribs[n][i].p2ind],1); 	// точка продолженния строповки на верхней поверхности
				}
			// добавим две реперных точек на лобике, а то мало по умолчанию
			panels[n][panels[n].length] = circle3d(panels[n][r][REPER1],1);
			panels[n][panels[n].length] = circle3d(panels[n][r][REPER2],1);
			}
		} else {	// реперные точки как % от общего числа точек в профиле
			step=Math.round((foil.length-1)/(print_reper*(foil.length-1)/100));
			for (i=step;i<foil.length-1;i+=step) {
				panels[n][panels[n].length] = circle3d(panels[n][2][i],1);	// LO
				panels[n][panels[n].length] = circle3d(panels[n][3][i],1);	// RO
				}
			}

	// дорисуем перпендикулярную линию на шве где начинается леска, высота линии равна ширине шва
	for (r=2;r<4;r++) {
		p=panels[n][r][L0];
		ple=ribs[n][L0+1];	// след. точка в отрезке, нужна для расчет перпендикуляра к нему
		ple=rotate_sew(p,ple,print_sew,(r==2));
		ar =  new Array();
		ar.add(p);
		ar.add(ple);
		panels[n][panels[n].length] = ar;
		}

	// дорисуем точку A0 где на лобике начинается вшитый шнур
	for (r=2;r<4;r++) {
		panels[n][panels[n].length] = circle3d(panels[n][r][A0],1);
		}


	// рисуем панель целиком, кроме первых двух полилиний (кроме исходной плоской панели, т.к. мы ее раздули на матрасность и отступ на шов делался относительно матрасной)
	if (opt_Show_Panels) {
		for (i=2;i<panels[n].length;i++) draw_polyline(panels[n][i], 0,0,dz);
		dz+=50;
		}//if opt_Show_Panels

	}// for all panels




// покажем кривые безье
if (opt_Show_Bezier) {
	if (opt_Show_Bezier==1) {
		draw_bezier(Bezier_LE);
		draw_bezier(Bezier_TE);
		draw_bezier(Bezier_AR);
		}
	// контрольные точки
	for(i=0;i<4;i++) if (i==1 || i==2 || opt_Show_Bezier==2) {
		circle3d({x:Bezier_LE[i*3], y:Bezier_LE[i*3+1], z:Bezier_LE[i*3+2]},0,5);
		circle3d({x:Bezier_TE[i*3], y:Bezier_TE[i*3+1], z:Bezier_TE[i*3+2]},0,5);
		circle3d({x:Bezier_AR[i*3], y:Bezier_AR[i*3+1], z:Bezier_AR[i*3+2]},0,5);
		}

	}


// трехмерная модель купола
if (opt_Show_Polygons) {
	// по всем нервюрам
	for (n=0;n<foils.length;n++) {
		step=opt_Show_Polygons;	 			// полигоны через столько точек
		// по всем точкам, кроме последней
		for (i=0;i+step<foils[n].length;i+=step){
			if (i+step*2>foils[n].length-1) step=foils[n].length-1-i;	// чтобы полигон всегда был на последней точке кривой независимо от шага

			p1=foils[n][i];
			p2=foils[n][i+step];
			if (n==0) {
				p3 = {x:-p1.x, y:p1.y, z:p1.z};
				p4 = {x:-p2.x, y:p2.y, z:p2.z};
				} else {
					p3=foils[n-1][i];
					p4=foils[n-1][i+step];
					}
			draw_tri(p1,p2,p4,p3);
			if (opt_Draw_Half==0 && n>0) {
				p1={x:-p1.x, y:p1.y, z:p1.z};
				p2={x:-p2.x, y:p2.y, z:p2.z};
				p3={x:-p3.x, y:p3.y, z:p3.z};
				p4={x:-p4.x, y:p4.y, z:p4.z};
				draw_tri(p3,p4,p2,p1);			// обратный порядок, чтобы полигоны были одного цвета
				}
			}
		}
	}


// завершающая часть файла (обязательно)
f.WriteLine("0\r\nENDSEC\r\n0\r\nEOF");
f.Close();



// --------------------------------------------------------------
// ПЕЧАТЬ
// --------------------------------------------------------------

if (print) {

offset = 2; // расстояние между выкройками когда несколько в одном файле
text_size=0.8;			 // высота текста, см

// ------------------------------
// печать нервюр


if (print==1) {
	f = fso.OpenTextFile("ribs.dxf",2,true);		// с перезаписью файлов
	f.WriteLine("0\r\nSECTION\r\n2\r\nENTITIES");			//начальная часть файла (обязательно)
	}

dz=0; dy=0;
// по всем нервюрам
for (n=0;n<ribs.length;n++) {
	if (print==2) {
		if (!fso.FolderExists("_print")) fso.CreateFolder("_print");
		f = fso.OpenTextFile("_print/rib_"+(n+1)+"_of_"+ribs.length+".dxf",2,true);		// с перезаписью файлов
		f.WriteLine("0\r\nSECTION\r\n2\r\nENTITIES");			//начальная часть файла (обязательно)
		}

	// рисуем
	for (i=0;i<ribs[n].lines.length;i++) draw_polyline(ribs[n].lines[i],0,-dy,dz,1);	// scale - печать в координатах XY, где x - это y, а y - это z и смасштабировать например в мм

	// текст с названием нервюры
	text((-11*text_size-dy),(ribs[n].lines[0][TE].z+dz),text_size,"Rib "+(n+1)+" of "+ribs.length);	// смещаем влево на длину текста (примерно найденную по высоте и количеству букв)

	// найдем смещение для следующей нервюры когда все в одном файле
	if (print==1) {
		zmin=ribs[n].lines[0][0].z;
		zmax=ribs[n].lines[0][0].z;
		for (i=0;i<ribs[n].lines.length;i++) for (j=0;j<ribs[n].lines[i].length;j++) {
			if (ribs[n].lines[i][j].z>zmax) zmax=ribs[n].lines[i][j].z;
			if (ribs[n].lines[i][j].z<zmin) zmin=ribs[n].lines[i][j].z;
			}
		 if (print_overlay_y!=0) dz+=print_overlay_y; else dz+=(zmax-zmin)+offset; //cm
		 if (print_overlay_x!=0) dy+=print_overlay_x;
		 }

	if (print==2) {
		// завершающая часть файла (обязательно)
		f.WriteLine("0\r\nENDSEC\r\n0\r\nEOF");
		f.Close();
		}
	}

if (print==1) {
	// завершающая часть файла (обязательно)
	f.WriteLine("0\r\nENDSEC\r\n0\r\nEOF");
	f.Close();
	}


// ------------------------------
// печать верхних панелей (аналогично нервюрам)

if (print==1) {
	f = fso.OpenTextFile("panels.dxf",2,true);		// с перезаписью файлов
	f.WriteLine("0\r\nSECTION\r\n2\r\nENTITIES");			//начальная часть файла (обязательно)
	}

dz=0;dy=0;
// по всем панелям
for (n=0;n<panels.length;n++) {
	if (print==2) {
		f = fso.OpenTextFile("_print/panel_"+(n+1)+"_of_"+panels.length+".dxf",2,true);		// с перезаписью файлов
		f.WriteLine("0\r\nSECTION\r\n2\r\nENTITIES");			//начальная часть файла (обязательно)
		}

	// рисуем, кроме первых двух где исходная плоская панель без матрасности
	for (i=2;i<panels[n].length;i++) draw_polyline(panels[n][i],0,dy,dz,1);	// 1 - печать в координатах XY, где x - это y, а y - это z

	// текст с названием панели, направление обычное так как TE слева
	text((1+dy),(panels[n][2][TE].z+dz+1),text_size,"TE <-- Panel "+(n+1)+" of "+panels.length+" (vv Center vv)  --> LE");	// смещаем влево на длину текста (примерно найденную по высоте и количеству букв)

	// найдем смещение для следующей панели когда все в одном файле
	if (print==1) {
		zmin=panels[n][0][0].z;
		zmax=panels[n][0][0].z;
		for (i=0;i<panels[n].length;i++) for (j=0;j<panels[n][i].length;j++) {
			if (panels[n][i][j].z>zmax) zmax=panels[n][i][j].z;
			if (panels[n][i][j].z<zmin) zmin=panels[n][i][j].z;
			}
		if (print_overlay_y!=0) dz+=print_overlay_y; else dz+=(zmax-zmin)+offset; //cm
		if (print_overlay_x!=0) dy+=print_overlay_x;
		}

	if (print==2) {
		// завершающая часть файла (обязательно)
		f.WriteLine("0\r\nENDSEC\r\n0\r\nEOF");
		f.Close();
		}
	}

if (print==1) {
	// завершающая часть файла (обязательно)
	f.WriteLine("0\r\nENDSEC\r\n0\r\nEOF");
	f.Close();
	}


}//print


// --------------------------------------------------------------
// ЛОКАЛИЗАЦИЯ, константы
// --------------------------------------------------------------

if (opt_eng==0) {
T1 = "Площадь ";
T2 = " м2\r\n";
T3 = "Удлинение ";
T4 = "Размах ";
T5 = " м\r\n\r\n";
T6 = "Проекц. площадь ";
T7 = "Проекц. удлинение ";
T8 = "Угол на крайней секции ";
T9 = " град";
T10 = "Проекц. размах ";
T11 = "\r\n!!! должен быть больше 90 град !!!";
T12 = "Средний угол строповки ";
T13 = "\r\nСТРОПОВКА\r\nНумерация строп от центроплана, в скобках длина с учетом узлов (длина на один узел ";
T14 = " см),\r\nа в квадратных скобках (если есть) длина строп верхнего яруса до точки на верхней поверхности как\r\nпродолжение строповки (можно использовать на ушах вместо крайней нервюры)\r\n\r\n";
T15 = "Передний конец\r\n";
T16 = "\r\nЗадний конец\r\n";
T17 = "Ряд A";
T18 = "Ряд B";
T19 = "Ряд CD";
T20 = " см)\r\n";
T21 = " см (";
T22 = "\tРяд C\r\n";
T23 = "\tРяд D\r\n";
T24 = "\t\tРяд ";
T25 = " см)";
T26 = " см]\r\n";
T27 = "\r\nУшная стропа\r\n\r\n";
T28 = "\r\nКлеванты\r\n\r\n";
T29 = "\r\nСТРОПОВКА ПО НЕРВЮРАМ\r\n\r\nНумерация нервюр от центра. В каждой нервюре длины строп по петелькам начиная от передней кромки,\r\nв скобках суммарная длина.\r\n";
T30 = "\r\nНервюра ";
T31 = " см   -   ";
T32 = "Общая длина шнура ";
T33 = " см\r\n";
T34 = "Количество секций ";
T35 = "Ширина секций ";
T36 = "Корневая хорда ";
T37 = " м\r\n";
T38 = "Концевая хорда ";
T39 = "Высота стропления ";
T40 = "\r\n\r\nОбщая длина строп ";
T41 = "С петельками на всех стропах ";
T42 = "С петельками на всех, кроме верхнего яруса ";
T43 = "Нижний ярус ";
T44 = " м (с петельками ";
T45 = " м)\r\n";
T46 = "Средний ярус ";
T47 = "Верхний ярус ";
T48 = "Верхний ярус из непрерывного шнура ";
T49 = " м (только контур ";
T50 = " м)\r\n\r\n";
T51 = " град\r\n";
T52 = "Угол отн. горизонта в центре ";
T53 = "Угол отн. горизонта на ушах ";
T54 = "Центр давления ";
T55 = "% на САХ соответствует ";
T56 = "% на центральной хорде\r\n";
T57 = "Точки крепления строп, % хорды [";
T58 = "ЛЕСКА В ЛОБИКЕ\r\nПо нервюрам, нумерация от центра.\r\n\r\n";
T59 = "\r\nСуммарная длина лески ";
T60 = " м";
T61 = "Расчет окончен. Модель и выкройки\nсохранены в соотв. файлы .dxf\n\n";
T62 = "Для изменения настроек откройте и\nотредактируйте этот файл в Блокноте.";
} else {
T1 = "Flat area ";
T2 = " m2\r\n";
T3 = "AR ";
T4 = "Wingspan ";
T5 = " m\r\n\r\n";
T6 = "Projected area ";
T7 = "Projected AR ";
T8 = "Angle at wingtip ";
T9 = " deg";
T10 = "Projected wingspan ";
T11 = "\r\n!!! must be greater 90 degree !!!";
T12 = "Average bridle angle ";
T13 = "\r\nBridles\r\nIndex from center, in parentheses length with knots (one knot length ";
T14 = " cm),\r\nin square parentheses(if shown) length to upper panel across rib triangles.\r\n\r\n";
T15 = "Front riser\r\n";
T16 = "\r\nRear riser\r\n";
T17 = "A";
T18 = "B";
T19 = "CD";
T20 = " cm)\r\n";
T21 = " cm (";
T22 = "\tC\r\n";
T23 = "\tD\r\n";
T24 = "\t\t ";
T25 = " cm)";
T26 = " cm]\r\n";
T27 = "\r\nWingtip line\r\n\r\n";
T28 = "\r\nBrakes\r\n\r\n";
T29 = "\r\nRibs countour\r\n\r\nIndex from center. Lines length by anchor points from front,\r\nin parentheses sum length.\r\n";
T30 = "\r\nRib ";
T31 = " cm   -   ";
T32 = "Sum length of all ribs ";
T33 = " cm\r\n";
T34 = "Num of cells ";
T35 = "Sell width ";
T36 = "Root chord ";
T37 = " m\r\n";
T38 = "Wingtip chord ";
T39 = "Bridles height ";
T40 = "\r\n\r\nSum line length ";
T41 = "With rib countours ";
T42 = "All, except upper cascade ";
T43 = "Lower cascade ";
T44 = " m (with countours ";
T45 = " m)\r\n";
T46 = "Mid cascade ";
T47 = "Upper cascade ";
T48 = "Upper cascade from continues cord ";
T49 = " m (only countours ";
T50 = " m)\r\n\r\n";
T51 = " deg\r\n";
T52 = "Angle at center ";
T53 = "Angle at wingtips ";
T54 = "Center of Pressure ";
T55 = "% on mean chord is equal ";
T56 = "% on center chord\r\n";
T57 = "Anchor points pos, % chord [";
T58 = "Plastic rods length\r\nBy ribs, index from center.\r\n\r\n";
T59 = "\r\nSum plastic rods length ";
T60 = " m";
T61 = "Calculation done.\n3D model and print plans\nsaved to .dxf files\n\n";
T62 = "To edit settings open and\nedit this script in Notepad.";

}


// --------------------------------------------------------------
// ПЕЧАТЬ ДЛИН СТРОП
// --------------------------------------------------------------

f = fso.OpenTextFile("bridle.txt",2,true);		// с перезаписью файлов

s="";

s+=T1+trim(foils.area)+T2;
s+=T3+trim(foils.AR)+"\r\n";
s+=T4+trim(foils.wingspan/100)+T5;

s+=T6+trim(foils.area_proj)+T2;
s+=T7+trim(foils.AR_proj)+"\r\n";
s+=T10+trim(foils.wingspan_proj/100)+" м\r\n\r\n";

// угол на ушах по третьей петельке, так как первые две могут попасть на лобик
p1 = bridle.ribs[foils.length-2][2].p2;		// точка на верхней поверхности как продолжение стрповки B1 предпоследней секции
p2 = bridle.ribs[foils.length-1][2].p2;		// последней секции
p3 = bridle.ribs[foils.length-1][2].p1;		// точка схождения строп
angle = pangle(p2,p1,p3)*180/Math.PI;	 // переводим в углы

s+=T8+trim(angle)+T9;
if (angle<=90) s+=T11;
s+="\r\n";

// посчитаем суммарный угол по всему куполу (растягивает или сжимает по размаху)
angle=0; num=0;
for (i=1;i<foils.length;i++) {
	// угол на ушах по третьей петельке, так как первые две могут попасть на лобик
	p1 = bridle.ribs[i-1][2].p2;		// точка на верхней поверхности как продолжение стрповки B1 предпоследней секции
	p2 = bridle.ribs[i][2].p2;		// последней секции
	p3 = bridle.ribs[i][2].p1;		// точка схождения строп
	angle += pangle(p2,p1,p3)*180/Math.PI;	 // переводим в углы
	num++;
	}
angle=angle/num;
s+=T12+trim(angle)+T9;
if (angle<=90) s+=T11;
s+="\r\n\r\n";

s1=s;


// определяем длины строп
num1=0;		  // количество строп нижнего яруса
num2=0;		  // среднего
num3=0;		  // верхнего

len1=0;		  // длина строп нижнего яруса
len2=0;		  // среднего
len3=0;		  // верхнего

// нижний ярус: arr[конец][А, В, CD_нижний ярус][AB_нижний ярус, CD_ряд][средний ярус][верхний ярус]

s="";
s+=T13+print_knot_length+T14;

if (opt_8p==2) print_up_level=0;	// контур нервюр с совмещенными А и В никогда не выводим, если 4 треугольника на нервюру

// по нижнему ярусу вдоль хорды по А, В, CD
for (i=0;i<3;i++) {

	if (i==0) s+=T15;
 	if (i==2) s+=T16;

	// выделим массив для каждого ряда
	s+="\r\n";
	if (i==0) {a=bridle.arr[0][0];	s+=T17;} 	// A
	if (i==1) {a=bridle.arr[0][1];	s+=T18;}	// B
	if (i==2) {a=bridle.arr[1];	s+=T19;}				// CD
	s+="\r\n";

	// теперь проходим по всем стропам нижнего яруса текущего ряда
	for (j=0;j<a.length;j++) {
		if (i<2) p1 = bridle.arr[0].p; else p1 = bridle.arr[1].p; 		  // точка окончания свободного переднего или заднего конца
		p2 = a[j].p;   			  			 	  						   // точка окончания нижнего яруса

		// длина
		d = pdist(p1,p2);
		len1+=d;
		num1++;

		s+=(j+1)+": "+trim1(d)+T21+trim1(d+print_knot_length*2)+T20;	// в скобках с учетом двух петелек

		// теперь в каждой стропе нижнего яруса проходим по каждой стропе среднего яруса
		for (k=0;k<2;k++) {		// по C и D
			if (i<2 && k>0) continue;		// для А и В пропускаем вторую половину цикла
			if (i==2 && k==0) s+=T22;
			if (i==2 && k==1) s+=T23;

			// определяем массив со стропами среднего яруса
			if (i==0) a1=bridle.arr[0][0][j];
			if (i==1) a1=bridle.arr[0][1][j];
			if (i==2) a1=bridle.arr[1][j][k];	// для CD изврат )


			// по всем стропам среднего яруса
			for (j1=0;j1<a1.length;j1++) {
				p3=a1[j1].p;   								// точка окончания среднего яруса

				// длина
				d = pdist(p2,p3);
				len2+=d;
				num2++;

				s+="\t"+(j1+1)+": "+trim1(d)+T21+trim1(d+print_knot_length*2)+T20;	// в скобках с учетом двух петелек

				// по всем стропам верхнего яруса идут по две точки вдоль хорды  			 									// точка окончания среднего яруса
				a2=a1[j1];
				for (j3=0;j3<2/opt_8p;j3++) {	// /2 так как всегда по две петельки вдоль хорды на одну стропу верхнего яруса
					s4=T24;
					if (i==0) s4+="A";
					if (i==1) s4+="B";
					if (i==2 && k==0) s4+="C";
					if (i==2 && k==1) s4+="D";
					if (j3==0) s4+="1"; else s4+="2";
					s4+="\r\n";
					if (print_up_level!=1 && opt_8p==1) s+=s4;
					for (j2=0;j2<a2.length/(2/opt_8p);j2++) {
						o = a2[j2*2/opt_8p+j3];										// объект {p:p, fnum:fnum, pnum:pnum, p2ind:bridle.points[pnum]}, кот. используется как bridle.ribs[o.fnum][o.pnum] = {p1:p, p2:o.p, p2ind:o.p2ind};
						// определим точку в вершине треугольника с индексом p2ind (точка o.p - на верхней поверхности как продолжение строповки)
						p4 = bridle.ribs[o.fnum][o.pnum].p;

						// длина
						d = pdist(p3,p4);
						len3+=d;
						num3++;

						s4="\t\t"+(j2+1)+": "+trim1(d)+T21+trim1(d+print_knot_length*2)+T25;	// в скобках с учетом двух петелек

						// и сохраним длину до верхней поверхности, может пригодиться для ушей
						p5=o.p; 				// точка на верхней поверхности как продолжение строповки
						d = pdist(p3,p5);
						s4+=" ["+trim1(d)+T26;						// длина до верхней поверхности

						if (print_up_level!=1) s+=s4;
						}
					}

				}

			}
		}
	}


// УШНАЯ СТРОПА, если есть
if (opt_Tip_Line) {
	s+=T27;
	a=bridle.arr[3];

	//
	p1 = bridle.arr[0].p;													// точка переднего концы
	p2 = a.p;   			  			 	  						    // точка окончания нижнего яруса ушной стропы

	// длина
	d = pdist(p1,p2);
	len2+=d;			// длину добавляем к среднему ярусу, так как ушная стропа обычно тольше нижнего яруса
	num2++;

	s+=(1)+": "+trim1(d)+T21+trim1(d+print_knot_length*2)+T20;			// в скобках с учетом двух петелек

	// по всем точкам
	for (i=0;i<8/opt_8p;i++) {
		// определим точку в вершине треугольника с индексом p2ind (точка o.p - на верхней поверхности как продолжение строповки)
		p3 = bridle.ribs[foils.length-1][i].p;

		// длина
		d = pdist(p2,p3);
		len3+=d;
		num3++;

		s+="\t"+(i+1)+": "+trim1(d)+T21+trim1(d+print_knot_length*2)+T20;	// в скобках с учетом двух петелек
		}
	}


// КЛЕВАНТЫ
s+=T28;
a=bridle.arr[2];

// нижний ярус, одна стропа
p1 = a.p0;													// начальная точка клевант (общая с кайтом и всегда без учета удлинителей)
p2 = a.p;   			  			 	  					// точка окончания нижнего яруса

// длина
d = pdist(p1,p2);
len1+=d;			// длину добавляем к нижнему ярусу
num1++;

s+=(1)+": "+trim1(d)+T21+trim1(d+print_knot_length*2)+T20;			// в скобках с учетом двух петелек

// средний ярус
for(i=0;i<a.length;i++) {													// точка карабинов
	p3 = a[i].p;   			  			 	  						    // точка окончания нижнего яруса

	// длина
	d = pdist(p2,p3);
	len2+=d;			// длину добавляем к нижнему ярусу
	num2++;

	s+="\t"+(i+1)+": "+trim1(d)+T21+trim1(d+print_knot_length*2)+T20;	// в скобках с учетом двух петелек

	// верхний ярус
	for (j=0;j<a[i].length;j++) {
		p4 = a[i][j].p;   			  			 	  						    // точка окончания нижнего яруса

		// длина
		d = pdist(p3,p4);
		len3+=d;			// длину добавляем к среднему ярусу
		num3++;

		s+="\t\t"+(j+1)+": "+trim1(d)+T21+trim1(d+print_knot_length*2)+T20;	// в скобках с учетом двух петелек
		}
	}



// по каждой нервюре
s3=T29;
lenb = 0;	// длина всех контуров нервюр
for (n=0;n<ribs.length;n++) {
	lenb+=ribs[n].len;
	d=0;
	s3+=T30+(n+1)+"\r\n";
	for (i=0;i<8/opt_8p;i+=2) {
		p0=bridle.ribs[n][i].p1;			// общая точка верхнего яруса
		p1=bridle.ribs[n][i].p;				// первая петелька
		p2=bridle.ribs[n][i+1].p;	  		// вторая петелька
		d1=pdist(p0,p1);
		d2=pdist(p0,p2);
		d+=d1+d2;
		if (i==0) s3+="A";
		if (i==2) s3+="B";
		if (i==4) s3+="C";
		if (i==6) s3+="D";
		s3+=": "+trim1(d1)+T31+trim1(d2)+T21+trim1(d1+d2)+T20;
		}
	s3+=T32+trim1(d+ribs[n].len)+T33;
	}
s3+="\r\n\r\n";
lenb*=2; 	// для двух полукрыльев
lenb/=100;	// в метры


// переводим в метры и удваиваем для двух полукрыльев
len1*=2/100;
len2*=2/100;
len3*=2/100;
num1*=2;
num2*=2;
num3*=2;

knot = print_knot_length/100;	// в метрах

lensum = (len1+len2+len3);
lensumknot = lensum + knot*2*(num1+num2+num3);
lensumknot2 = lensum + knot*2*(num1+num2);

// с петельками
len1p= len1 + knot*2*num1;
len2p= len2 + knot*2*num2;
len3p= len3 + knot*2*num3;

s2="";
s2+=T34+(opt_Cells*2+1)+"\r\n";
s2+=T35+trim(foils.cell_width)+T33;
s2+=T36+trim(foils[0].chord/100)+T37;
s2+=T38+trim(foils[foils.length-1].chord/100)+T37;
s2+=T39+trim(-bridle.origin.z/100)+T37;


s2+=T40+trim(lensum)+T37;
s2+=T41+trim(lensumknot)+T37;
s2+=T42+trim(lensumknot2)+T37;

s2+="\r\n";
s2+=T43+trim(len1)+T44+trim(len1p)+T45;
s2+=T46+trim(len2)+T44+trim(len2p)+T45;
s2+=T47+trim(len3)+T44+trim(len3p)+T45;
s2+=T48+trim(len3+lenb)+T49+trim(lenb)+T50;
s2+=T52+trim(foils[0].angle)+T51;
s2+=T53+trim(foils[foils.length-1].angle)+T51;
s2+=T54+opt_CoP+T55+trim(foils.CAX.CAX_Center)+T56;

s2+=T57;
for (i=0;i<opt_Bridle_Points.length;i++) {
	s2+=trim(opt_Bridle_Points[i]);
	if (i<opt_Bridle_Points.length-1) s2+=",";
	}
s2+="]\r\n";
s2+="\r\n\r\n";


s4=T58;
lensum=0;
for(i=0;i<foils.length;i++) {
	len=0;
	for(j=L0;j<foils[i].length-1;j++) len+=pdist(foils[i][j],foils[i][j+1]);
	s4+=(i+1)+": "+trim1(len)+T33;
	lensum+=len;
	}
lensum*=2;	// для двух полукрыльев
s4+=T59+trim(lensum/100)+T60;
s4+="\r\n\r\n";

if (print_up_level==0) s3="";	// не выводить верхний ярус отдельно по нервюрам
f.WriteLine(s1+s2+s4+s3+s);
f.Close();

// выводим результат только если запуск скрипта напрямую, через GUI выходим молча
if (!g_GUI) WScript.echo(T61+s1+T62);

// --------------------------------------------------------------
// ФУНКЦИИ
// --------------------------------------------------------------

function rotate_sew(p1,p2,sew,inverted,inv) {
	// возвращает точку на шве, p1,p2 - отрезок, sew - ширина шва, inverted - надо ли инвертировать угол, inv - инвертировать вес шов
	// смещаем в начало координат
	var y = p2.y-p1.y;
	var z = p2.z-p1.z;

	// определяем угол с осью Y (для первого отрезка от хвостика 161 градус)
	var len = Math.sqrt(y*y+z*z);				// гипотенуза
	var angle=Math.acos(y/len)*180/Math.PI;		// сразу переводим из радиан в углы
	if (z<0) angle=180+(180-angle);	 		 	// ВНИМАНИЕ! это чтобы был охват диапазона 360 градусов, т.к. косинус работает только в диапазоне 0..180 градусов

	angle = angle - 90; 					 	// поворачиваем назад на 90 градусов
	if (inverted) angle+=180;	   	  		 	// для последней точки инвертируем угол
	if (inv) angle+=180;	   	  		 	 	// инвертируем угол для всего шва (используется для панелей верхней поверхности)
	angle = angle*Math.PI/180; 	  			 	// обратно в радианы

	// создаем новую точку в массив
	var p = {x:p1.x,y:0,z:0};

	// поворачиваем отрезок длиной в шов и смещаем в положение начала отрезка
	x=0; y=sew;
	p.y = y * Math.cos(angle) + p1.y;
	p.z = y * Math.sin(angle) + p1.z;
	return p;
	}

function add_sew(a,sew,inv,flag,begin,end) {	// создает и возвращает массив с полилинией отступа для шва, а - массив с точкам, sew - отступ в см, inv - шов в другую сторону, flag - делать только со второй половины массива (исп. на первой петельке)
	// ВНИМАНИЕ! предполагается, что сечение лежит в плоскости YZ, то есть перпендикулярно на оси X
	var arr = new Array();
	var inverted;
	// по всем точкам
	for (var i=0;i<a.length;i++) if (!flag || flag && i>a.length/2) {
		// для последней точки инвертируем направление отрезка
		if (i<a.length-1) {p1=a[i];p2=a[i+1];} else {p1=a[i];p2=a[i-1];}
		if (i==a.length-1) inverted=true; else inverted=false;

		// для первой точки делаем отступ назад на расстояние begin, подрисовывая короткий отрезок, чтобы соединить с началом пред. шва на лобике нервюры
		if (i==0 && begin) {
			var p = rotate_sew(p1,p2,begin,inverted,inv); // поворачиваем 90 град
			p = rotate_sew(p1,p,begin,inverted,inv); 	  // еще на 90, в сумме получается 180 град
			arr.add(rotate_sew(p,p1,sew,inverted,inv));
			}

		// для прямых треугольников делаем более точное соответствий линий шва оригинальной линии
		if (opt_Rib_Straight) {
			// для промежуточных точек найдем дополнительную точку в обратном направлении
		 	if (i>0 && i<a.length-1) {
				var tp1=a[i];
				var tp2=a[i-1];
				var tinverted=true;
				arr.add(rotate_sew(tp1,tp2,sew,tinverted,inv));
				}
			}

		// добавляем точку на шве в массив
		arr.add(rotate_sew(p1,p2,sew,inverted,inv));

		// для построенных предыдущих линий попробуем найти пересечения отрезков и удалить возникающие угольники-артефакты
		if (opt_Rib_Straight && arr.length>=5) {	  // для формирования артефакта должно быть минимум 5 предыдущих точек
			var t1 = arr[arr.length-1];
			var t2 = arr[arr.length-2];
			var t3 = arr[arr.length-3];
			var t4 = arr[arr.length-4];
			var res = intersect(t1.y,t1.z, t2.y,t2.z, t3.y,t3.z, t4.y,t4.z);	// внимание! вместо х,у, реальные координаты y,z
			if (res[0]!=0 && res[1]!=0) {
				// есть пересечение отрезков! удалим артефакт, заменив две точки на одну (точнее, задав их координаты как координаты пересечения, т.е. длина соедининяющего их отрезка станет равна нулю )
				arr[arr.length-2] = {x:0,y:res[0],z:res[1]};
				arr[arr.length-3] = {x:0,y:res[0],z:res[1]};
				}
			}



		// для конца после последней точки тоже добавляем короткий отрезок, чтобы соединить со след. швом
		if (i==a.length-1 && end) {
			p = rotate_sew(p1,p2,end,inverted,inv);  	// поворачиваем 90 град
			p = rotate_sew(p1,p,end,inverted,inv); 	  	// еще на 90, в сумме получается 180 град
			arr.add(rotate_sew(p,p1,sew,inverted,inv));
			}

		}
	return arr;
	}



function draw_tri(p1,p2,p3,p4) {
		// рисуем треугольник/четырехугольник
		if (!p4) p4 = {x:p3.x, y:p3.y, z:p3.z};		// четвертый вертекс обязателен всегда

		f.WriteLine("0\r\n3DFACE");
		f.WriteLine("8\r\n0");		// слой 0
		f.WriteLine("10\r\n"+p1.x*print_scale);	// x
		f.WriteLine("20\r\n"+p1.y*print_scale);	// y
		f.WriteLine("30\r\n"+p1.z*print_scale);	// z

		f.WriteLine("11\r\n"+p2.x*print_scale);	// x
		f.WriteLine("21\r\n"+p2.y*print_scale);	// y
		f.WriteLine("31\r\n"+p2.z*print_scale);	// z

		f.WriteLine("12\r\n"+p3.x*print_scale);	// x
		f.WriteLine("22\r\n"+p3.y*print_scale);	// y
		f.WriteLine("32\r\n"+p3.z*print_scale);	// z

		f.WriteLine("13\r\n"+p4.x*print_scale);	// x
		f.WriteLine("23\r\n"+p4.y*print_scale);	// y
		f.WriteLine("33\r\n"+p4.z*print_scale);	// z

		}

function len_polyline(a) {
	// возвращает длину полилинии
	var len=0;
	for (var i=0;i<a.length-1;i++) {
		len+=pdist(a[i],a[i+1]);
		}
	return len;
	}

function draw_polyline(a,dx,dy,dz, XY) {	// а - массив точек p{x,y,z} с соотв. смещением, XY - в плоскости (для печати) и перевести например в мм
		// рисуем полилинию
		var x=0; var y=0; var z=0;
		if (arguments.length>1) x=dx;
		if (arguments.length>2) y=dy;
		if (arguments.length>3) z=dz;

		if (!XY) {
			f.WriteLine("0\r\nPOLYLINE");	// POLYLINE, потом 38 - высота z, потом 10,20,10,20
			f.WriteLine("70\r\n8");			// флаг, что это 3D Polyline
			f.WriteLine("8\r\n0");			// обязательно для полилиний поле с названием слоя 0
			f.WriteLine("66\r\n1");			// обязательно поле для полилиний
			}
		var skip;		// можно пропускать точки и рисовать упрощенные кривые, например через каждые 5 точек
		if (a.length==2) skip=1; else skip=opt_Polyline_Step;
		var iprev=0;
		for (var i=0;i<a.length;i+=skip) {
			if (i+skip>a.length-1) skip=a.length-1-i;
			if (skip<1) skip=1;

			if (!XY) {
				f.WriteLine("0\r\nVERTEX");
				// трехмерная точка
				f.WriteLine("8\r\n0");	// слой 0
				f.WriteLine("10\r\n"+(a[i].x+x)*print_scale);	// x
				f.WriteLine("20\r\n"+(a[i].y+y)*print_scale);	// y
				f.WriteLine("30\r\n"+(a[i].z+z)*print_scale);	// z
				} else if (i>=skip) {
					// на плоскости рисуем только отдельными линиями
					f.WriteLine("0\r\nLINE");
					f.WriteLine("8\r\n0");	// слой 0
					f.WriteLine("10\r\n"+(a[iprev].y+y)*print_scale);	// x вместо y
					f.WriteLine("20\r\n"+(a[iprev].z+z)*print_scale);	// y вместо z
					f.WriteLine("11\r\n"+(a[i].y+y)*print_scale);
					f.WriteLine("21\r\n"+(a[i].z+z)*print_scale);
					iprev=i;
					}
			}
		if (!XY) f.WriteLine("0\r\nSEQEND");		// конец последовательности вертексов в POLYLINE
		}


function bezier(b,t,coord){	// b=[x,y,z, x,y,z, ...], t=0..1, coord="x"|"y"|"z"
	// возвращает x или y или z кубической или квадратичной кривой безье b (с четырьмя или тремя контрольными точками) для заданного параметра t=0..1

	// кривая безье по 4 точкам, точки последовательно от первой до последней
	// B(t) = (1-t)^3 * P0 + 3*t*(1-t)^2 * P1 + 3*t^2*(1-t) * P2 + t^3*P3, t=[0..1]

	// кривая безье по 3 точкам, точки последовательно от первой до последней
	// B(t) = (1-t)^2 * P0 + 2*t*(1-t) * P1 + t^2*P2, t=[0..1]

	var i=0; var res; 	// если не использовать var, то переопределит глобальную i
	if (coord=="x") i=0; else if (coord=="y") i=1; else if (coord=="z") i=2; else {
		// не указано, вернем точку
		var p = {x:bezier(b,t,"x"), y:bezier(b,t,"y"), z:bezier(b,t,"z")};
		return p;
		}

	if (b.length==3*3) res = (1-t)*(1-t) * b[0+i] + 2*t*(1-t) * b[3+i] + t*t*b[3*2+i];
		else res = (1-t)*(1-t)*(1-t) * b[0+i] + 3*t*(1-t)*(1-t) * b[3+i] + 3*t*t*(1-t) * b[3*2+i] + t*t*t*b[3*3+i];
	return res;
	}


function draw_bezier(b,ret) {	// ret=1 - только вернуть массив точек, не рисуя кривую
	var t=0; var x=0; var y=0; var z=0;
	var arr=new Array();

	// рисуем
	if (!ret) {
		f.WriteLine("0\r\nPOLYLINE");		// POLYLINE, потом 38 - высота z, потом 10,20,10,20
		f.WriteLine("70\r\n8");			// флаг, что это 3D Polyline
		f.WriteLine("8\r\n0");			// обязательно для полилиний поле с названием слоя 0
		f.WriteLine("66\r\n1");			// обязательно поле для полилиний
		}

	// чтобы последняя точка всегда имела значение 1, иначе маленькое отклонение из-за float часто не выводит последнюю точку
	var step=1/opt_Bezier_Step;
	var num=0;
	for (t=0;t<=1;t=num*step) {				// далее для каждой точки свой VERTEX
		num++;
		x = bezier(b,t,"x");
		y = bezier(b,t,"y");
		z = bezier(b,t,"z");

		// если нужно вернуть массив точек, то добавим точку в архив (с помощью созданного нами для массивов метода .add)
		if (ret) arr.add(x,y,z); else {
			f.WriteLine("0\r\nVERTEX");
			f.WriteLine("8\r\n0");	// слой 0
			f.WriteLine("10\r\n"+x*print_scale);	// x
			f.WriteLine("20\r\n"+y*print_scale);	// y
			f.WriteLine("30\r\n"+z*print_scale);	// z
			}
		}
	if (!ret) f.WriteLine("0\r\nSEQEND");		// конец последовательности вертексов в POLYLINE
	if (ret) return arr;
	}

function draw_btri(ar,n, inv) {	// ar массив с точками безье, n - индекс профиля/нервюры
	// нарисуем полигональные треугольники нервюр
	var min1; var min2; var ind1; var ind2; var d; var p; var i; var i1; var i2;
	for (var j=0;j<ar.length-1;j++) {
		// ищем наиболее близкую вертикальную точку на нервюре

		 // СТАРЫЙ ВАРИАНТ, полным перебором
		min1=99999; min2=99999; ind1=0; ind2=0;
		for (var k=0;k<LE;k++) { // до LE!
			p = foils[n][k];
			if (inv) p = {x:-p.x, y:p.y, z:p.z};
			d=pdist(ar[j],p);
			if (d<min1) {min1=d; ind1=k;} else break;		// для ускорения

			d=pdist(ar[j+1],p);
			if (d<min2) {min2=d; ind2=k;}
			}


		// рисуем четырехугольник
		p = foils[n][ind1];
		if (inv) p = {x:-p.x, y:p.y, z:p.z};
		var p2 = foils[n][ind2];
		if (inv) p2 = {x:-p2.x, y:p2.y, z:p2.z};
		draw_tri(p,p2,ar[j+1],ar[j]);
		}
	}

function draw_straight_line(p1,p2,n) {
	// рисует одну прямую линию треугольника с прямыми линиями, а также полигон и зеркальную копию
	pline3d(p1,p2);
	// создадим временную кривую безье, совпадающую с прямой линией, чтобы задействовать готовые функции отрисовки полигонов по кривой безье
	var b = new Array(p1.x,p1.y,p1.z, (p1.x+p2.x)/2,(p1.y+p2.y)/2,(p1.z+p2.z)/2, p2.x,p2.y,p2.z);	// средняя точка безье лежит посередине между крайними, чтобы полигоны были равномерные
	var ar = draw_bezier(b,1); 	   		   		   	// возвращает только массив с точками
	if (opt_Show_Rib_Polygons) draw_btri(ar,n);	// рисуем полигоны

	// зеркальная копия
	if (opt_Draw_Half==0) {
		b[0]=-b[0];
		b[3]=-b[3];
		b[6]=-b[6];
		ar = draw_bezier(b,1);
		draw_polyline(ar);
		if (opt_Show_Rib_Polygons) draw_btri(ar,n, 1);	//inv
		}
	}

function draw_straight(b, p1,p3, n) {
	// рисует один полный треугольник с прямыми линиями по оригинальной кривой безье b, p1 - начальная точка, p3 - конечная точка, n - индекс нервюры (нужен для поиска ближайшей точки на нервюре при построении полигонов)
	// найдем точку середины оригинальной кривой безье
	var p2 = {x:bezier(b,0.5,"x"), y:bezier(b,0.5,"y"), z:bezier(b,0.5,"z")};
	// рисуем треугольник из двух частей, по одной прямой линии...
	draw_straight_line(p1,p2, n);
	draw_straight_line(p2,p3, n);
	}

function line(x1,y1,x2,y2) {
	// рисует линию, координаты x1,y1,x2,y2 относительно центра тек. сечения
	f.WriteLine("0\r\nLINE");
	f.WriteLine("8\r\n0");	// слой 0
	f.WriteLine("10\r\n"+x1*print_scale);	//+dx,+dy - смещение тек. сечения
	f.WriteLine("20\r\n"+y1*print_scale);
	f.WriteLine("11\r\n"+x2*print_scale);
	f.WriteLine("21\r\n"+y2*print_scale);
	}

function line3d(x1,y1,z1,x2,y2,z2,sew) {
	// рисует линию
	f.WriteLine("0\r\nLINE");
	f.WriteLine("8\r\n0");	// слой 0
	f.WriteLine("10\r\n"+x1*print_scale);
	f.WriteLine("20\r\n"+y1*print_scale);
	f.WriteLine("30\r\n"+z1*print_scale);
	f.WriteLine("11\r\n"+x2*print_scale);
	f.WriteLine("21\r\n"+y2*print_scale);
	f.WriteLine("31\r\n"+z2*print_scale);
	}

function pline3d(p1,p2) {	// P{x,y,z}
	line3d(p1.x,p1.y,p1.z, p2.x,p2.y,p2.z);
	}
function pline3dr(p1,p2) {	// P{x,y,z}	// реверс x
	line3d(-p1.x,p1.y,p1.z, -p2.x,p2.y,p2.z);
	}


function circle(x,y,r) {
	// рисует круг
	f.WriteLine("0\r\nCIRCLE");
	f.WriteLine("8\r\n0");		// слой 0
	f.WriteLine("10\r\n"+x*print_scale);
	f.WriteLine("20\r\n"+y*print_scale);
	f.WriteLine("40\r\n"+r*print_scale);
	}

function circle3d(p,ret,r) {	// ret=1 - только вернуть массив с точками
	// нарисуем крестик линиями
	if (!r) r=print_circle_size/20;	   // по умолчанию размер точки в см, /20 т.к. переводим мм в см и еще на 2, т.к. используется как отступы от центральной координаты
	if (!ret) {
		line3d(p.x,p.y-r,p.z-r, p.x,p.y+r,p.z+r);
		line3d(p.x,p.y-r,p.z+r, p.x,p.y+r,p.z-r);
		line3d(p.x-r,p.y,p.z, p.x+r,p.y,p.z);
		} else {
			var arr=new Array();
			arr.add(p.x,p.y-r,p.z-r);
			arr.add(p.x,p.y+r,p.z+r);
			arr.add(p.x,p.y-r,p.z+r);
			arr.add(p.x,p.y+r,p.z-r);
			arr.add(p.x,p.y-r,p.z-r);
			return arr;
			}
	}

function text(x,y,size,text){
	// текст
	f.WriteLine("0\r\nTEXT");
	f.WriteLine("8\r\n0");		// слой 0
	f.WriteLine("10\r\n"+x*print_scale);
	f.WriteLine("20\r\n"+y*print_scale);
	f.WriteLine("40\r\n"+size*print_scale);
	f.WriteLine("1\r\n"+text);
	}

function rect(x,y,z){
	f.WriteLine("0\nLWPOLYLINE");
	f.WriteLine("38\n"+z);
	rx=x/2;
	ry=y/2;
	f.WriteLine("10\n"+(-rx));
	f.WriteLine("20\n"+(-ry));
	f.WriteLine("10\n"+(rx));
	f.WriteLine("20\n"+(-ry));
	f.WriteLine("10\n"+(rx));
	f.WriteLine("20\n"+(ry));
	f.WriteLine("10\n"+(-rx));
	f.WriteLine("20\n"+(ry));
	f.WriteLine("10\n"+(-rx));
	f.WriteLine("20\n"+(-ry));
	f.WriteLine("0\nSEQEND");
	}


function intersect(x1,y1,x2,y2,xx1,yy1,xx2,yy2,lines) {	// lines == true если пересечение прямых, false для отрезков, (x1,y1) - (x2,y2) - первый отрезок, (xx1,yy1) - (xx2,yy2) - первый отрезок, возвращает точку пересечения в виде массива [0]=x,[1]=y или [0,0] если пересечения нет

	var res = new Array(0,0); // по умолчанию не пересекаются

	// если прямые...
	if (lines) {

	// уравнение первой прямой Ах+Bx+C=0
	var A1 = (y1-y2);
	var B1 = (x2-x1);
	var C1 = (x1*y2 - x2*y1);

	// уравнение второй прямой Ах+Bx+C=0
	var A2 = (yy1-yy2);
	var B2 = (xx2-xx1);
	var C2 = (xx1*yy2 - xx2*yy1);

	// точка пересечения прямых
	var znam = (A1*B2 - A2*B1);
	if (znam!=0) {
		res[0] = (B1*C2 - B2*C1)/znam;	// x
		res[1] = (C1*A2 - C2*A1)/znam;	// y
		}

	// возвращаем точку пересечения прямых в виде массива [0]=x,[1]=y или [0,0] если нет пересечения
	return res;
	}

	// если отрезки...
	var a=x2-x1;
	var b=xx1-xx2;
	var c=xx1-x1;
	var d=y2-y1;
	var e=yy1-yy2;
	var f=yy1-y1;

	var det=a*e-b*d;
	if (det==0) return res;
	var dt=c*e-f*b;
	var ds=a*f-c*d;
	var t=dt/det;
	var s=ds/det;

	if (0<=s && s<=1 && 0<=t && t<=1) {
		res[0]=x1*(1-t)+x2*t;
		res[1]=y1*(1-t)+y2*t;
		}


	// возвращаем точку пересечения отрезков в виде массива [0]=x,[1]=y или [0,0] если нет пересечения
	return res;
	}


function fangle(x1,y1,z1,x2,y2,z2,x3,y3,z3) {	// возвращает угол в радианах между двумя отрезками, первая точка - общая

	var x = x2-x1;
	var y = y2-y1;
	var z = z2-z1;
	var xx = x3-x1;
	var yy = y3-y1;
	var zz = z3-z1;

	var cos = (x*xx+y*yy+z*zz)/(Math.sqrt(x*x+y*y+z*z)*Math.sqrt(xx*xx+yy*yy+zz*zz));
	var res = Math.acos(cos);		// возвращает угол в радианах! для перевода в углы надо *180/Math.PI;

	return res;
	}
function pangle(p1,p2,p3){	// для точек P{x,y,z}
	return fangle(p1.x,p1.y,p1.z, p2.x,p2.y,p2.z, p3.x,p3.y,p3.z);
	}

function dist(x1,y1,z1,x2,y2,z2) {
	var x = x2-x1;
	var y = y2-y1;
	var z = z2-z1;
	var dist = Math.sqrt(x*x+y*y+z*z);
	return dist;
	}
function pdist(p1,p2) {	// для точек P{x,y,z}
	return dist(p1.x,p1.y,p1.z, p2.x,p2.y,p2.z);
	}

function trim(v){
	// округляем до х.хх
	return Math.round(v*100)/100;
	}
function trim1(v){
	// округляем до х.х
	return Math.round(v*10)/10;
	}


function getArg() {
	// заменяем переменные на те, что пришли в командной строке
	var n = WScript.Arguments.Named;

	if (n.Exists("opt_Area")) opt_Area = n.Item("opt_Area")*1; // *1 - неявное преобразование строки в число
	if (n.Exists("opt_AR")) opt_AR = n.Item("opt_AR")*1;
	if (n.Exists("opt_Cells")) opt_Cells = n.Item("opt_Cells")*1;
	if (n.Exists("opt_Kite_Lines")) opt_Kite_Lines = n.Item("opt_Kite_Lines")*1;
	if (n.Exists("opt_CoP")) opt_CoP = n.Item("opt_CoP")*1;
	if (n.Exists("opt_K")) opt_K = n.Item("opt_K")*1;
	if (n.Exists("opt_AoA")) opt_AoA = n.Item("opt_AoA")*1;
	if (n.Exists("opt_AoA_Tips")) opt_AoA_Tips = n.Item("opt_AoA_Tips")*1;
	if (n.Exists("opt_Camber_Center")) opt_Camber_Center = n.Item("opt_Camber_Center")*1;
	if (n.Exists("opt_Camber_Tip")) opt_Camber_Tip = n.Item("opt_Camber_Tip")*1;
	if (n.Exists("opt_Tip_Width")) opt_Tip_Width = n.Item("opt_Tip_Width")*1;
	if (n.Exists("opt_8p")) opt_8p = n.Item("opt_8p")*1;
	if (n.Exists("opt_Rib_Size")) opt_Rib_Size = n.Item("opt_Rib_Size")*1;
	if (n.Exists("opt_Rib_Koeff")) opt_Rib_Koeff = n.Item("opt_Rib_Koeff")*1;
	if (n.Exists("opt_Rib_Camber")) opt_Rib_Camber = n.Item("opt_Rib_Camber")*1;
	if (n.Exists("opt_Rib_Straight")) opt_Rib_Straight = n.Item("opt_Rib_Straight")*1;
	if (n.Exists("opt_Bridle_Height")) opt_Bridle_Height = n.Item("opt_Bridle_Height")*1;
	if (n.Exists("opt_Bridle_Riser")) opt_Bridle_Riser = n.Item("opt_Bridle_Riser")*1;
	if (n.Exists("opt_Bridle_Riser_Dist")) opt_Bridle_Riser_Dist = n.Item("opt_Bridle_Riser_Dist")*1;
	if (n.Exists("opt_Bridle_Upper")) opt_Bridle_Upper = n.Item("opt_Bridle_Upper")*1;
	if (n.Exists("opt_Bridle_Upper_Num")) opt_Bridle_Upper_Num = n.Item("opt_Bridle_Upper_Num")*1;
	if (n.Exists("opt_Bridle_Middle")) opt_Bridle_Middle = n.Item("opt_Bridle_Middle")*1;
	if (n.Exists("opt_Bridle_Middle_Num")) opt_Bridle_Middle_Num = n.Item("opt_Bridle_Middle_Num")*1;
	if (n.Exists("opt_Tip_Line")) opt_Tip_Line = n.Item("opt_Tip_Line")*1;
	if (n.Exists("opt_Tip_Line_Height")) opt_Tip_Line_Height = n.Item("opt_Tip_Line_Height")*1;

	if (n.Exists("opt_Brake")) {
		opt_Brake = n.Item("opt_Brake"); // СТРОКА 2,1
		opt_Brake = opt_Brake.split(",");
		for (i=0;i<opt_Brake.length;i++) opt_Brake[i] = trim(opt_Brake[i])*1;
		}

	if (n.Exists("opt_Brake_Upper")) opt_Brake_Upper = n.Item("opt_Brake_Upper")*1;
	if (n.Exists("opt_Brake_Upper_Num")) opt_Brake_Upper_Num = n.Item("opt_Brake_Upper_Num")*1;
	if (n.Exists("opt_Brake_Middle")) opt_Brake_Middle = n.Item("opt_Brake_Middle")*1;

	if (n.Exists("opt_Bridle_Points")) {
		opt_Bridle_Points = n.Item("opt_Bridle_Points"); // СТРОКА 15,27,50,80
		opt_Bridle_Points = opt_Bridle_Points.split(",");
		for (i=0;i<opt_Bridle_Points.length;i++) opt_Bridle_Points[i] = trim(opt_Bridle_Points[i])*1;
		}

	if (n.Exists("opt_Bridle_A0")) opt_Bridle_A0 = n.Item("opt_Bridle_A0")*1;
	if (n.Exists("opt_Bridle_L0")) opt_Bridle_L0 = n.Item("opt_Bridle_L0")*1;
	if (n.Exists("print")) print = n.Item("print")*1;
	if (n.Exists("print_overlay_y")) print_overlay_y = n.Item("print_overlay_y")*1;
	if (n.Exists("print_overlay_x")) print_overlay_x = n.Item("print_overlay_x")*1;
	if (n.Exists("print_knot_length")) print_knot_length = n.Item("print_knot_length")*1;
	if (n.Exists("print_LE")) print_LE = n.Item("print_LE")*1;
	if (n.Exists("print_TE")) print_TE = n.Item("print_TE")*1;
	if (n.Exists("print_sew")) print_sew = n.Item("print_sew")*1;
	if (n.Exists("print_sew_rib")) print_sew_rib = n.Item("print_sew_rib")*1;

	if (n.Exists("print_oval")) print_oval = {LE:n.Item("print_oval_LE")*1, TE:n.Item("print_oval_TE")*1, val:n.Item("print_oval_val")*1};


	if (n.Exists("print_reper")) print_reper = n.Item("print_reper")*1;
	if (n.Exists("print_circle_size")) print_circle_size = n.Item("print_circle_size")*1;
	if (n.Exists("opt_Rib_Scale")) opt_Rib_Scale = n.Item("opt_Rib_Scale")*1;
	if (n.Exists("opt_AoA_Twist")) opt_AoA_Twist = n.Item("opt_AoA_Twist")*1;
	if (n.Exists("opt_Bezier_Step")) opt_Bezier_Step = n.Item("opt_Bezier_Step")*1;
	if (n.Exists("opt_Show_Polygons")) opt_Show_Polygons = n.Item("opt_Show_Polygons")*1;

	// кривые бельзе
	if (n.Exists("Bezier_LE")) {
		tmp = n.Item("Bezier_LE"); // СТРОКА 15,27,50,
		tmp = tmp.split(",");
		for (i=0;i<Bezier_LE.length;i++) Bezier_LE[i] = trim(tmp[i])*1;
		}

	if (n.Exists("Bezier_TE")) {
		tmp = n.Item("Bezier_TE"); // СТРОКА 15,27,50,
		tmp = tmp.split(",");
		for (i=0;i<Bezier_TE.length;i++) Bezier_TE[i] = trim(tmp[i])*1;
		}

	if (n.Exists("Bezier_AR")) {
		tmp = n.Item("Bezier_AR"); // СТРОКА 15,27,50,
		tmp = tmp.split(",");
		for (i=0;i<Bezier_AR.length;i++) Bezier_AR[i] = trim(tmp[i])*1;
		}

	if (n.Exists("opt_eng")) opt_eng = n.Item("opt_eng")*1;

	}


//WScript.echo("ok");
WScript.quit();
</script>
</job>